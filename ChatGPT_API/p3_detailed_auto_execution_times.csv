function_index,prompt,sample_index,code_segment,Size,Min,Average,Max,Exception
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def partition(nums, low, high):\n    pivot = nums[high]\n    i = low - 1\n    for j in range(low, high):\n        if nums[j] <= pivot:\n            i += 1\n            nums[i], nums[j] = (nums[j], nums[i])\n    nums[i + 1], nums[high] = (nums[high], nums[i + 1])\n    return i + 1\n\ndef quickselect(nums, k):\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        pivot_index = partition(nums, low, high)\n        if pivot_index == k - 1:\n            return nums[:k]\n        elif pivot_index > k - 1:\n            high = pivot_index - 1\n        else:\n            low = pivot_index + 1\n    return nums[:k]\n\ndef funcImp(nums, k):\n    return quickselect(nums, k)']",200,0.07673269999213517,0.08188934000441804,0.1129493999760598,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def partition(nums, low, high):\n    pivot = nums[high]\n    i = low - 1\n    for j in range(low, high):\n        if nums[j] <= pivot:\n            i += 1\n            nums[i], nums[j] = (nums[j], nums[i])\n    nums[i + 1], nums[high] = (nums[high], nums[i + 1])\n    return i + 1\n\ndef quickselect(nums, k):\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        pivot_index = partition(nums, low, high)\n        if pivot_index == k - 1:\n            return nums[:k]\n        elif pivot_index > k - 1:\n            high = pivot_index - 1\n        else:\n            low = pivot_index + 1\n    return nums[:k]\n\ndef funcImp(nums, k):\n    return quickselect(nums, k)']",300,0.17138539999723434,0.17830964601133018,0.18477739999070764,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def partition(nums, low, high):\n    pivot = nums[high]\n    i = low - 1\n    for j in range(low, high):\n        if nums[j] <= pivot:\n            i += 1\n            nums[i], nums[j] = (nums[j], nums[i])\n    nums[i + 1], nums[high] = (nums[high], nums[i + 1])\n    return i + 1\n\ndef quickselect(nums, k):\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        pivot_index = partition(nums, low, high)\n        if pivot_index == k - 1:\n            return nums[:k]\n        elif pivot_index > k - 1:\n            high = pivot_index - 1\n        else:\n            low = pivot_index + 1\n    return nums[:k]\n\ndef funcImp(nums, k):\n    return quickselect(nums, k)']",600,0.6963927999604493,0.7169656579918228,0.7325107001233846,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    if k < 1:\n        return []\n    elif k >= len(arr):\n        return list(range(len(arr)))\n\n    def partition(start, end):\n        pivot_index = end\n        pivot_value = arr[pivot_index]\n        i = start\n        for j in range(start, end):\n            if arr[j] < pivot_value:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[pivot_index] = (arr[pivot_index], arr[i])\n        return i\n    start = 0\n    end = len(arr) - 1\n    while True:\n        pivot_index = partition(start, end)\n        if pivot_index == k:\n            return sorted(range(k), key=lambda i: arr[i])\n        elif pivot_index > k:\n            end = pivot_index - 1\n        else:\n            start = pivot_index + 1']",200,0.07972989999689162,0.08597349498886615,0.08925669989548624,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    if k < 1:\n        return []\n    elif k >= len(arr):\n        return list(range(len(arr)))\n\n    def partition(start, end):\n        pivot_index = end\n        pivot_value = arr[pivot_index]\n        i = start\n        for j in range(start, end):\n            if arr[j] < pivot_value:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[pivot_index] = (arr[pivot_index], arr[i])\n        return i\n    start = 0\n    end = len(arr) - 1\n    while True:\n        pivot_index = partition(start, end)\n        if pivot_index == k:\n            return sorted(range(k), key=lambda i: arr[i])\n        elif pivot_index > k:\n            end = pivot_index - 1\n        else:\n            start = pivot_index + 1']",300,0.18376290006563067,0.19051028901012615,0.19588230014778674,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    if k < 1:\n        return []\n    elif k >= len(arr):\n        return list(range(len(arr)))\n\n    def partition(start, end):\n        pivot_index = end\n        pivot_value = arr[pivot_index]\n        i = start\n        for j in range(start, end):\n            if arr[j] < pivot_value:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[pivot_index] = (arr[pivot_index], arr[i])\n        return i\n    start = 0\n    end = len(arr) - 1\n    while True:\n        pivot_index = partition(start, end)\n        if pivot_index == k:\n            return sorted(range(k), key=lambda i: arr[i])\n        elif pivot_index > k:\n            end = pivot_index - 1\n        else:\n            start = pivot_index + 1']",600,0.7531033998820931,0.770036475006491,0.7877132999710739,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['import heapq\n\ndef funcImp(arr, k):\n    heap = []\n    for i, val in enumerate(arr):\n        if i < k:\n            heapq.heappush(heap, (-val, i))\n        elif -val > heap[0][0]:\n            heapq.heappushpop(heap, (-val, i))\n    return [heapq.heappop(heap)[1] for i in range(k)]']",200,0.0008205999620258808,0.0009362719859927893,0.001117900013923645,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['import heapq\n\ndef funcImp(arr, k):\n    heap = []\n    for i, val in enumerate(arr):\n        if i < k:\n            heapq.heappush(heap, (-val, i))\n        elif -val > heap[0][0]:\n            heapq.heappushpop(heap, (-val, i))\n    return [heapq.heappop(heap)[1] for i in range(k)]']",300,0.0011766001116484404,0.0013144849869422615,0.001564200036227703,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['import heapq\n\ndef funcImp(arr, k):\n    heap = []\n    for i, val in enumerate(arr):\n        if i < k:\n            heapq.heappush(heap, (-val, i))\n        elif -val > heap[0][0]:\n            heapq.heappushpop(heap, (-val, i))\n    return [heapq.heappop(heap)[1] for i in range(k)]']",600,0.002302400069311261,0.002456650985404849,0.002648100024089217,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    dict_nums = {}\n    for i in range(len(arr)):\n        dict_nums[i] = arr[i]\n    sorted_dict = sorted(dict_nums.items(), key=lambda x: x[1])[:k]\n    indices = [index for index, value in sorted_dict]\n    return indices']",200,0.001559099880978465,0.0016560770035721362,0.0018885999452322721,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    dict_nums = {}\n    for i in range(len(arr)):\n        dict_nums[i] = arr[i]\n    sorted_dict = sorted(dict_nums.items(), key=lambda x: x[1])[:k]\n    indices = [index for index, value in sorted_dict]\n    return indices']",300,0.002230199985206127,0.002422778992913663,0.0027341998647898436,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    dict_nums = {}\n    for i in range(len(arr)):\n        dict_nums[i] = arr[i]\n    sorted_dict = sorted(dict_nums.items(), key=lambda x: x[1])[:k]\n    indices = [index for index, value in sorted_dict]\n    return indices']",600,0.0048228001687675714,0.005216025011613965,0.005839999997988343,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(val, idx) for idx, val in enumerate(arr)]\n    heapq.heapify(heap)\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res']",200,0.0009588999673724174,0.0010454430035315453,0.0011674000415951014,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(val, idx) for idx, val in enumerate(arr)]\n    heapq.heapify(heap)\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res']",300,0.0014500999823212624,0.0015351889980956912,0.0019104999955743551,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(val, idx) for idx, val in enumerate(arr)]\n    heapq.heapify(heap)\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res']",600,0.002933099865913391,0.003102187984623015,0.003594400128349662,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    if k < 1 or k > len(arr):\n        return []\n\n    def partition(arr, l, r):\n        pivot = arr[r]\n        i = l - 1\n        for j in range(l, r):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = (arr[j], arr[i])\n        arr[i + 1], arr[r] = (arr[r], arr[i + 1])\n        return i + 1\n\n    def select(arr, l, r, k):\n        if l == r:\n            return arr[l]\n        q = partition(arr, l, r)\n        left_len = q - l + 1\n        if k == left_len:\n            return arr[q]\n        elif k < left_len:\n            return select(arr, l, q - 1, k)\n        else:\n            return select(arr, q + 1, r, k - left_len)\n    kth_smallest = select(arr, 0, len(arr) - 1, k)\n    indexes = []\n    for i, num in enumerate(arr):\n        if num <= kth_smallest:\n            indexes.append(i)\n            if len(indexes) == k:\n                break\n    return indexes']",200,0.08135609980672598,0.08479756000451744,0.0938701000995934,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    if k < 1 or k > len(arr):\n        return []\n\n    def partition(arr, l, r):\n        pivot = arr[r]\n        i = l - 1\n        for j in range(l, r):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = (arr[j], arr[i])\n        arr[i + 1], arr[r] = (arr[r], arr[i + 1])\n        return i + 1\n\n    def select(arr, l, r, k):\n        if l == r:\n            return arr[l]\n        q = partition(arr, l, r)\n        left_len = q - l + 1\n        if k == left_len:\n            return arr[q]\n        elif k < left_len:\n            return select(arr, l, q - 1, k)\n        else:\n            return select(arr, q + 1, r, k - left_len)\n    kth_smallest = select(arr, 0, len(arr) - 1, k)\n    indexes = []\n    for i, num in enumerate(arr):\n        if num <= kth_smallest:\n            indexes.append(i)\n            if len(indexes) == k:\n                break\n    return indexes']",300,0.1784007998649031,0.18485802000854165,0.19454199983738363,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    if k < 1 or k > len(arr):\n        return []\n\n    def partition(arr, l, r):\n        pivot = arr[r]\n        i = l - 1\n        for j in range(l, r):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = (arr[j], arr[i])\n        arr[i + 1], arr[r] = (arr[r], arr[i + 1])\n        return i + 1\n\n    def select(arr, l, r, k):\n        if l == r:\n            return arr[l]\n        q = partition(arr, l, r)\n        left_len = q - l + 1\n        if k == left_len:\n            return arr[q]\n        elif k < left_len:\n            return select(arr, l, q - 1, k)\n        else:\n            return select(arr, q + 1, r, k - left_len)\n    kth_smallest = select(arr, 0, len(arr) - 1, k)\n    indexes = []\n    for i, num in enumerate(arr):\n        if num <= kth_smallest:\n            indexes.append(i)\n            if len(indexes) == k:\n                break\n    return indexes']",600,0.7152515000198036,0.7381422649975866,0.7787835001945496,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['import random\n\ndef funcImp(arr, k):\n    """"""\n    Finds the indexes of k smallest numbers in an unsorted array.\n    args:\n        arr: a list of integers.\n        k: an integer representing the k smallest number.\n    returns:\n        a list of indexes of k smallest numbers in the original array.\n    """"""\n\n    def swap(i, j):\n        arr[i], arr[j] = (arr[j], arr[i])\n\n    def partition(left, right, pivot_index):\n        pivot_value = arr[pivot_index]\n        swap(pivot_index, right)\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot_value:\n                swap(i, store_index)\n                store_index += 1\n        swap(store_index, right)\n        return store_index\n\n    def select(left, right, k_smallest):\n        if left == right:\n            return left\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(left, right, pivot_index)\n        if k_smallest == pivot_index:\n            return k_smallest\n        elif k_smallest < pivot_index:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n    n = len(arr)\n    kth_smallest_index = select(0, n - 1, k - 1)\n    indexes = []\n    for i in range(k):\n        smallest_num = arr[kth_smallest_index]\n        indexes.append(kth_smallest_index)\n        kth_smallest_index = arr.index(smallest_num, kth_smallest_index + 1)\n    return indexes']",0,0,0,0,"function_index: 0 , code_start_index: 192, Error: 4 is not in list"
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['import random\n\ndef funcImp(nums, k):\n    """"""\n    Returns the indexes of the k smallest numbers in an unsorted array.\n    """"""\n\n    def partition(left, right, pivot_idx):\n        pivot_value = nums[pivot_idx]\n        nums[pivot_idx], nums[right] = (nums[right], nums[pivot_idx])\n        store_idx = left\n        for i in range(left, right):\n            if nums[i] < pivot_value:\n                nums[store_idx], nums[i] = (nums[i], nums[store_idx])\n                store_idx += 1\n        nums[right], nums[store_idx] = (nums[store_idx], nums[right])\n        return store_idx\n\n    def quickselect(left, right, k_smallest):\n        if left == right:\n            return left\n        pivot_idx = random.randint(left, right)\n        pivot_idx = partition(left, right, pivot_idx)\n        if k_smallest == pivot_idx:\n            return pivot_idx\n        elif k_smallest < pivot_idx:\n            return quickselect(left, pivot_idx - 1, k_smallest)\n        else:\n            return quickselect(pivot_idx + 1, right, k_smallest)\n    k_smallest_idx = quickselect(0, len(nums) - 1, k - 1)\n    result = []\n    for i, num in enumerate(nums):\n        if num <= nums[k_smallest_idx] and len(result) < k:\n            result.append(i)\n    return result']",200,0.0018066000193357468,0.0020244910079054534,0.002365000080317259,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['import random\n\ndef funcImp(nums, k):\n    """"""\n    Returns the indexes of the k smallest numbers in an unsorted array.\n    """"""\n\n    def partition(left, right, pivot_idx):\n        pivot_value = nums[pivot_idx]\n        nums[pivot_idx], nums[right] = (nums[right], nums[pivot_idx])\n        store_idx = left\n        for i in range(left, right):\n            if nums[i] < pivot_value:\n                nums[store_idx], nums[i] = (nums[i], nums[store_idx])\n                store_idx += 1\n        nums[right], nums[store_idx] = (nums[store_idx], nums[right])\n        return store_idx\n\n    def quickselect(left, right, k_smallest):\n        if left == right:\n            return left\n        pivot_idx = random.randint(left, right)\n        pivot_idx = partition(left, right, pivot_idx)\n        if k_smallest == pivot_idx:\n            return pivot_idx\n        elif k_smallest < pivot_idx:\n            return quickselect(left, pivot_idx - 1, k_smallest)\n        else:\n            return quickselect(pivot_idx + 1, right, k_smallest)\n    k_smallest_idx = quickselect(0, len(nums) - 1, k - 1)\n    result = []\n    for i, num in enumerate(nums):\n        if num <= nums[k_smallest_idx] and len(result) < k:\n            result.append(i)\n    return result']",300,0.0026209999341517687,0.002849685004912317,0.003374699968844652,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['import random\n\ndef funcImp(nums, k):\n    """"""\n    Returns the indexes of the k smallest numbers in an unsorted array.\n    """"""\n\n    def partition(left, right, pivot_idx):\n        pivot_value = nums[pivot_idx]\n        nums[pivot_idx], nums[right] = (nums[right], nums[pivot_idx])\n        store_idx = left\n        for i in range(left, right):\n            if nums[i] < pivot_value:\n                nums[store_idx], nums[i] = (nums[i], nums[store_idx])\n                store_idx += 1\n        nums[right], nums[store_idx] = (nums[store_idx], nums[right])\n        return store_idx\n\n    def quickselect(left, right, k_smallest):\n        if left == right:\n            return left\n        pivot_idx = random.randint(left, right)\n        pivot_idx = partition(left, right, pivot_idx)\n        if k_smallest == pivot_idx:\n            return pivot_idx\n        elif k_smallest < pivot_idx:\n            return quickselect(left, pivot_idx - 1, k_smallest)\n        else:\n            return quickselect(pivot_idx + 1, right, k_smallest)\n    k_smallest_idx = quickselect(0, len(nums) - 1, k - 1)\n    result = []\n    for i, num in enumerate(nums):\n        if num <= nums[k_smallest_idx] and len(result) < k:\n            result.append(i)\n    return result']",600,0.004896899918094277,0.005497094998136162,0.006161599885672331,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(lst, k):\n\n    def partition(lst, left, right):\n        pivot = lst[left]\n        i = left + 1\n        j = right\n        while True:\n            while i <= j and lst[i] <= pivot:\n                i += 1\n            while j >= i and lst[j] >= pivot:\n                j -= 1\n            if i >= j:\n                break\n            lst[i], lst[j] = (lst[j], lst[i])\n        lst[left], lst[j] = (lst[j], lst[left])\n        return j\n    left = 0\n    right = len(lst) - 1\n    while left <= right:\n        pivot_index = partition(lst, left, right)\n        if pivot_index == k - 1:\n            break\n        elif pivot_index < k - 1:\n            left = pivot_index + 1\n        else:\n            right = pivot_index - 1\n    return sorted(range(k), key=lambda i: lst[i])']",200,0.0012342000845819712,0.002052210015244782,0.002435700036585331,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(lst, k):\n\n    def partition(lst, left, right):\n        pivot = lst[left]\n        i = left + 1\n        j = right\n        while True:\n            while i <= j and lst[i] <= pivot:\n                i += 1\n            while j >= i and lst[j] >= pivot:\n                j -= 1\n            if i >= j:\n                break\n            lst[i], lst[j] = (lst[j], lst[i])\n        lst[left], lst[j] = (lst[j], lst[left])\n        return j\n    left = 0\n    right = len(lst) - 1\n    while left <= right:\n        pivot_index = partition(lst, left, right)\n        if pivot_index == k - 1:\n            break\n        elif pivot_index < k - 1:\n            left = pivot_index + 1\n        else:\n            right = pivot_index - 1\n    return sorted(range(k), key=lambda i: lst[i])']",300,0.0028599000070244074,0.003087555996607989,0.003522000042721629,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(lst, k):\n\n    def partition(lst, left, right):\n        pivot = lst[left]\n        i = left + 1\n        j = right\n        while True:\n            while i <= j and lst[i] <= pivot:\n                i += 1\n            while j >= i and lst[j] >= pivot:\n                j -= 1\n            if i >= j:\n                break\n            lst[i], lst[j] = (lst[j], lst[i])\n        lst[left], lst[j] = (lst[j], lst[left])\n        return j\n    left = 0\n    right = len(lst) - 1\n    while left <= right:\n        pivot_index = partition(lst, left, right)\n        if pivot_index == k - 1:\n            break\n        elif pivot_index < k - 1:\n            left = pivot_index + 1\n        else:\n            right = pivot_index - 1\n    return sorted(range(k), key=lambda i: lst[i])']",600,0.0050397999584674835,0.006320485000032932,0.006845500087365508,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import heapq\n\ndef funcImp(arr, k):\n    pq = []\n    for i in range(k):\n        heapq.heappush(pq, (-arr[i], i))\n    for i in range(k, len(arr)):\n        if arr[i] < -pq[0][0]:\n            heapq.heappop(pq)\n            heapq.heappush(pq, (-arr[i], i))\n    indexes = []\n    for i in range(k):\n        index = heapq.heappop(pq)[1]\n        indexes.append(index)\n    return indexes']",200,0.0006198999471962452,0.0007829189952462912,0.0012691000010818243,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import heapq\n\ndef funcImp(arr, k):\n    pq = []\n    for i in range(k):\n        heapq.heappush(pq, (-arr[i], i))\n    for i in range(k, len(arr)):\n        if arr[i] < -pq[0][0]:\n            heapq.heappop(pq)\n            heapq.heappush(pq, (-arr[i], i))\n    indexes = []\n    for i in range(k):\n        index = heapq.heappop(pq)[1]\n        indexes.append(index)\n    return indexes']",300,0.0008977001998573542,0.0010475749988108874,0.001762900035828352,N/A
0_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import heapq\n\ndef funcImp(arr, k):\n    pq = []\n    for i in range(k):\n        heapq.heappush(pq, (-arr[i], i))\n    for i in range(k, len(arr)):\n        if arr[i] < -pq[0][0]:\n            heapq.heappop(pq)\n            heapq.heappush(pq, (-arr[i], i))\n    indexes = []\n    for i in range(k):\n        index = heapq.heappop(pq)[1]\n        indexes.append(index)\n    return indexes']",600,0.0016751999501138926,0.0018581640068441629,0.0020697000436484814,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(num, i) for i, num in enumerate(arr[:k])]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return sorted([heapq.heappop(heap)[1] for _ in range(k)])']",200,0.000515099847689271,0.0005890309764072299,0.0006603999063372612,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(num, i) for i, num in enumerate(arr[:k])]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return sorted([heapq.heappop(heap)[1] for _ in range(k)])']",300,0.0007273999508470297,0.0008123139990493655,0.0010989001020789146,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(num, i) for i, num in enumerate(arr[:k])]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return sorted([heapq.heappop(heap)[1] for _ in range(k)])']",600,0.0014725001528859138,0.0015780209982767701,0.0021965999621897936,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['import random\n\ndef funcImp(arr, k):\n\n    def partition(arr, l, r):\n        p = arr[r]\n        i = l\n        for j in range(l, r):\n            if arr[j] < p:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[r] = (arr[r], arr[i])\n        return i\n\n    def quickselect(arr, l, r, k):\n        if l == r:\n            return l\n        pivot_index = random.randint(l, r)\n        arr[pivot_index], arr[r] = (arr[r], arr[pivot_index])\n        pivot_index = partition(arr, l, r)\n        if k == pivot_index:\n            return k\n        elif k < pivot_index:\n            return quickselect(arr, l, pivot_index - 1, k)\n        else:\n            return quickselect(arr, pivot_index + 1, r, k)\n    indices = []\n    for i in range(k):\n        index = quickselect(arr, 0, len(arr) - 1, i)\n        indices.append(index)\n    return indices']",200,0.0067800001706928015,0.007484523991588503,0.008077400038018823,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['import random\n\ndef funcImp(arr, k):\n\n    def partition(arr, l, r):\n        p = arr[r]\n        i = l\n        for j in range(l, r):\n            if arr[j] < p:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[r] = (arr[r], arr[i])\n        return i\n\n    def quickselect(arr, l, r, k):\n        if l == r:\n            return l\n        pivot_index = random.randint(l, r)\n        arr[pivot_index], arr[r] = (arr[r], arr[pivot_index])\n        pivot_index = partition(arr, l, r)\n        if k == pivot_index:\n            return k\n        elif k < pivot_index:\n            return quickselect(arr, l, pivot_index - 1, k)\n        else:\n            return quickselect(arr, pivot_index + 1, r, k)\n    indices = []\n    for i in range(k):\n        index = quickselect(arr, 0, len(arr) - 1, i)\n        indices.append(index)\n    return indices']",300,0.00961569999344647,0.01050540001830086,0.011342500103637576,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['import random\n\ndef funcImp(arr, k):\n\n    def partition(arr, l, r):\n        p = arr[r]\n        i = l\n        for j in range(l, r):\n            if arr[j] < p:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[r] = (arr[r], arr[i])\n        return i\n\n    def quickselect(arr, l, r, k):\n        if l == r:\n            return l\n        pivot_index = random.randint(l, r)\n        arr[pivot_index], arr[r] = (arr[r], arr[pivot_index])\n        pivot_index = partition(arr, l, r)\n        if k == pivot_index:\n            return k\n        elif k < pivot_index:\n            return quickselect(arr, l, pivot_index - 1, k)\n        else:\n            return quickselect(arr, pivot_index + 1, r, k)\n    indices = []\n    for i in range(k):\n        index = quickselect(arr, 0, len(arr) - 1, i)\n        indices.append(index)\n    return indices']",600,0.01831209985539317,0.019844643003307284,0.021326699992641807,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['def partition(arr, left, right):\n    pivot = arr[right]\n    i = left\n    for j in range(left, right):\n        if arr[j] < pivot:\n            arr[i], arr[j] = (arr[j], arr[i])\n            i += 1\n    arr[i], arr[right] = (arr[right], arr[i])\n    return i\n\ndef find_k_smallest(arr, k):\n    left, right = (0, len(arr) - 1)\n    while True:\n        pivot_idx = partition(arr, left, right)\n        if pivot_idx == k - 1:\n            return sorted(arr[:k])\n        elif pivot_idx < k - 1:\n            left = pivot_idx + 1\n        else:\n            right = pivot_idx - 1']",200,0.00698600010946393,0.0074777720007114115,0.008204800076782703,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['def partition(arr, left, right):\n    pivot = arr[right]\n    i = left\n    for j in range(left, right):\n        if arr[j] < pivot:\n            arr[i], arr[j] = (arr[j], arr[i])\n            i += 1\n    arr[i], arr[right] = (arr[right], arr[i])\n    return i\n\ndef find_k_smallest(arr, k):\n    left, right = (0, len(arr) - 1)\n    while True:\n        pivot_idx = partition(arr, left, right)\n        if pivot_idx == k - 1:\n            return sorted(arr[:k])\n        elif pivot_idx < k - 1:\n            left = pivot_idx + 1\n        else:\n            right = pivot_idx - 1']",300,0.009731100173667073,0.010602543002460153,0.01139540015719831,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['def partition(arr, left, right):\n    pivot = arr[right]\n    i = left\n    for j in range(left, right):\n        if arr[j] < pivot:\n            arr[i], arr[j] = (arr[j], arr[i])\n            i += 1\n    arr[i], arr[right] = (arr[right], arr[i])\n    return i\n\ndef find_k_smallest(arr, k):\n    left, right = (0, len(arr) - 1)\n    while True:\n        pivot_idx = partition(arr, left, right)\n        if pivot_idx == k - 1:\n            return sorted(arr[:k])\n        elif pivot_idx < k - 1:\n            left = pivot_idx + 1\n        else:\n            right = pivot_idx - 1']",600,0.018434200203046203,0.019871665998362004,0.02100179996341467,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(nums, k):\n    if k > len(nums):\n        return []\n    smallest = sorted(nums)[:k]\n    indexes = {}\n    for i in range(len(nums)):\n        if nums[i] in smallest:\n            if nums[i] in indexes:\n                indexes[nums[i]].append(i)\n            else:\n                indexes[nums[i]] = [i]\n    result = []\n    for num in smallest:\n        result.extend(indexes[num])\n    return result']",200,0.0009439000859856606,0.0009930129977874457,0.00115430005826056,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(nums, k):\n    if k > len(nums):\n        return []\n    smallest = sorted(nums)[:k]\n    indexes = {}\n    for i in range(len(nums)):\n        if nums[i] in smallest:\n            if nums[i] in indexes:\n                indexes[nums[i]].append(i)\n            else:\n                indexes[nums[i]] = [i]\n    result = []\n    for num in smallest:\n        result.extend(indexes[num])\n    return result']",300,0.00143989990465343,0.0015081599960103632,0.001942700007930398,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(nums, k):\n    if k > len(nums):\n        return []\n    smallest = sorted(nums)[:k]\n    indexes = {}\n    for i in range(len(nums)):\n        if nums[i] in smallest:\n            if nums[i] in indexes:\n                indexes[nums[i]].append(i)\n            else:\n                indexes[nums[i]] = [i]\n    result = []\n    for num in smallest:\n        result.extend(indexes[num])\n    return result']",600,0.003053099848330021,0.0031847349973395467,0.003739400068297982,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['def funcImp(arr, k):\n    indices = {}\n    for i in range(len(arr)):\n        if arr[i] in indices:\n            indices[arr[i]].append(i)\n        else:\n            indices[arr[i]] = [i]\n    sorted_values = sorted(set(arr))\n    k_smallest = sorted_values[:k]\n    k_indices = []\n    for value in k_smallest:\n        indices_list = indices[value]\n        k_indices.extend(indices_list[:k - len(k_indices)])\n        if len(k_indices) == k:\n            break\n    return k_indices']",200,0.001401199959218502,0.0014678170043043793,0.0017268001101911068,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['def funcImp(arr, k):\n    indices = {}\n    for i in range(len(arr)):\n        if arr[i] in indices:\n            indices[arr[i]].append(i)\n        else:\n            indices[arr[i]] = [i]\n    sorted_values = sorted(set(arr))\n    k_smallest = sorted_values[:k]\n    k_indices = []\n    for value in k_smallest:\n        indices_list = indices[value]\n        k_indices.extend(indices_list[:k - len(k_indices)])\n        if len(k_indices) == k:\n            break\n    return k_indices']",300,0.0019956999458372593,0.0021078879991546272,0.002557799918577075,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['def funcImp(arr, k):\n    indices = {}\n    for i in range(len(arr)):\n        if arr[i] in indices:\n            indices[arr[i]].append(i)\n        else:\n            indices[arr[i]] = [i]\n    sorted_values = sorted(set(arr))\n    k_smallest = sorted_values[:k]\n    k_indices = []\n    for value in k_smallest:\n        indices_list = indices[value]\n        k_indices.extend(indices_list[:k - len(k_indices)])\n        if len(k_indices) == k:\n            break\n    return k_indices']",600,0.004084999905899167,0.004294078000821173,0.004767999984323978,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"[""def funcImp(arr, k):\n    heap = [(float('-inf'), -1)] * k\n    heapify(heap)\n    for i, num in enumerate(arr):\n        if num < heap[0][0]:\n            heappop(heap)\n            heappush(heap, (num, i))\n    return sorted([x[1] for x in heap])""]",0,0,0,0,"function_index: 1 , code_start_index: 178, Error: name 'heapify' is not defined"
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['def funcImp(arr, k):\n    indexes = []\n    if k == 0:\n        return indexes\n    min_heap = []\n    for i, num in enumerate(arr):\n        if i < k:\n            heapq.heappush(min_heap, (-num, i))\n        elif num < -min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (-num, i))\n    while min_heap:\n        indexes.append(min_heap[0][1])\n        heapq.heappop(min_heap)\n    return indexes']",200,0.0007417001761496067,0.0009045900031924248,0.0011893999762833118,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['def funcImp(arr, k):\n    indexes = []\n    if k == 0:\n        return indexes\n    min_heap = []\n    for i, num in enumerate(arr):\n        if i < k:\n            heapq.heappush(min_heap, (-num, i))\n        elif num < -min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (-num, i))\n    while min_heap:\n        indexes.append(min_heap[0][1])\n        heapq.heappop(min_heap)\n    return indexes']",300,0.0011202001478523016,0.0012833649991080165,0.0016994001343846321,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['def funcImp(arr, k):\n    indexes = []\n    if k == 0:\n        return indexes\n    min_heap = []\n    for i, num in enumerate(arr):\n        if i < k:\n            heapq.heappush(min_heap, (-num, i))\n        elif num < -min_heap[0][0]:\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (-num, i))\n    while min_heap:\n        indexes.append(min_heap[0][1])\n        heapq.heappop(min_heap)\n    return indexes']",600,0.002091099973767996,0.002306280005723238,0.0034716001246124506,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n\n    def quickselect(arr, left, right, k):\n        if left == right:\n            return arr[left]\n        pivot_index = random.randint(left, right)\n        arr[right], arr[pivot_index] = (arr[pivot_index], arr[right])\n        pivot_index = left\n        for i in range(left, right):\n            if arr[i] < arr[right]:\n                arr[i], arr[pivot_index] = (arr[pivot_index], arr[i])\n                pivot_index += 1\n        arr[right], arr[pivot_index] = (arr[pivot_index], arr[right])\n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return quickselect(arr, left, pivot_index - 1, k)\n        else:\n            return quickselect(arr, pivot_index + 1, right, k)\n    kth_smallest = quickselect(arr, 0, len(arr) - 1, k - 1)\n    result = []\n    for i, num in enumerate(arr):\n        if num <= kth_smallest:\n            result.append(i)\n            if len(result) == k:\n                break\n    return result']",200,0.0014874001499265432,0.0016919289832003415,0.0019197000656276941,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n\n    def quickselect(arr, left, right, k):\n        if left == right:\n            return arr[left]\n        pivot_index = random.randint(left, right)\n        arr[right], arr[pivot_index] = (arr[pivot_index], arr[right])\n        pivot_index = left\n        for i in range(left, right):\n            if arr[i] < arr[right]:\n                arr[i], arr[pivot_index] = (arr[pivot_index], arr[i])\n                pivot_index += 1\n        arr[right], arr[pivot_index] = (arr[pivot_index], arr[right])\n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return quickselect(arr, left, pivot_index - 1, k)\n        else:\n            return quickselect(arr, pivot_index + 1, right, k)\n    kth_smallest = quickselect(arr, 0, len(arr) - 1, k - 1)\n    result = []\n    for i, num in enumerate(arr):\n        if num <= kth_smallest:\n            result.append(i)\n            if len(result) == k:\n                break\n    return result']",300,0.002104000188410282,0.0023826740146614613,0.002964999992400408,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n\n    def quickselect(arr, left, right, k):\n        if left == right:\n            return arr[left]\n        pivot_index = random.randint(left, right)\n        arr[right], arr[pivot_index] = (arr[pivot_index], arr[right])\n        pivot_index = left\n        for i in range(left, right):\n            if arr[i] < arr[right]:\n                arr[i], arr[pivot_index] = (arr[pivot_index], arr[i])\n                pivot_index += 1\n        arr[right], arr[pivot_index] = (arr[pivot_index], arr[right])\n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return quickselect(arr, left, pivot_index - 1, k)\n        else:\n            return quickselect(arr, pivot_index + 1, right, k)\n    kth_smallest = quickselect(arr, 0, len(arr) - 1, k - 1)\n    result = []\n    for i, num in enumerate(arr):\n        if num <= kth_smallest:\n            result.append(i)\n            if len(result) == k:\n                break\n    return result']",600,0.0039091999642550945,0.00439780299551785,0.005193499848246574,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq._heapify_max(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq._heapreplace_max(heap, (arr[i], i))\n    result = [heapq.heappop(heap)[1] for i in range(k)][::-1]\n    return result']",200,0.0005781999789178371,0.0006865620077587664,0.0008528002072125673,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq._heapify_max(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq._heapreplace_max(heap, (arr[i], i))\n    result = [heapq.heappop(heap)[1] for i in range(k)][::-1]\n    return result']",300,0.0008187999483197927,0.0009176449989899992,0.0010665999725461006,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq._heapify_max(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq._heapreplace_max(heap, (arr[i], i))\n    result = [heapq.heappop(heap)[1] for i in range(k)][::-1]\n    return result']",600,0.0015562002081423998,0.0016883310000412165,0.0019030999392271042,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import random\n\ndef quickSelect(lst, k):\n    """"""Select the kth smallest element in lst (0 based)""""""\n    if len(lst) == 1:\n        return lst[0]\n    pivot = random.choice(lst)\n    lows = [el for el in lst if el < pivot]\n    highs = [el for el in lst if el > pivot]\n    pivots = [el for el in lst if el == pivot]\n    if k < len(lows):\n        return quickSelect(lows, k)\n    elif k < len(lows) + len(pivots):\n        return pivots[0]\n    else:\n        return quickSelect(highs, k - len(lows) - len(pivots))\n\ndef funcImp(lst, k):\n    """"""Return the indices of the k smallest elements in lst""""""\n    smallest = []\n    for i in range(k):\n        smallest.append(quickSelect(lst, i))\n    result = [i for i, x in enumerate(lst) if x in smallest]\n    return result']",200,0.011574100004509091,0.012250346005894244,0.013126099947839975,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import random\n\ndef quickSelect(lst, k):\n    """"""Select the kth smallest element in lst (0 based)""""""\n    if len(lst) == 1:\n        return lst[0]\n    pivot = random.choice(lst)\n    lows = [el for el in lst if el < pivot]\n    highs = [el for el in lst if el > pivot]\n    pivots = [el for el in lst if el == pivot]\n    if k < len(lows):\n        return quickSelect(lows, k)\n    elif k < len(lows) + len(pivots):\n        return pivots[0]\n    else:\n        return quickSelect(highs, k - len(lows) - len(pivots))\n\ndef funcImp(lst, k):\n    """"""Return the indices of the k smallest elements in lst""""""\n    smallest = []\n    for i in range(k):\n        smallest.append(quickSelect(lst, i))\n    result = [i for i, x in enumerate(lst) if x in smallest]\n    return result']",300,0.0162708000279963,0.017205543001182377,0.01836200011894107,N/A
1_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import random\n\ndef quickSelect(lst, k):\n    """"""Select the kth smallest element in lst (0 based)""""""\n    if len(lst) == 1:\n        return lst[0]\n    pivot = random.choice(lst)\n    lows = [el for el in lst if el < pivot]\n    highs = [el for el in lst if el > pivot]\n    pivots = [el for el in lst if el == pivot]\n    if k < len(lows):\n        return quickSelect(lows, k)\n    elif k < len(lows) + len(pivots):\n        return pivots[0]\n    else:\n        return quickSelect(highs, k - len(lows) - len(pivots))\n\ndef funcImp(lst, k):\n    """"""Return the indices of the k smallest elements in lst""""""\n    smallest = []\n    for i in range(k):\n        smallest.append(quickSelect(lst, i))\n    result = [i for i, x in enumerate(lst) if x in smallest]\n    return result']",600,0.03030480002053082,0.0319534910027869,0.03347059991210699,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def funcImp(arr, k):\n    dict_arr = {}\n    for i in range(len(arr)):\n        dict_arr[arr[i]] = i\n    smallest_k = sorted(arr)[:k]\n    result = []\n    for num in smallest_k:\n        result.append(dict_arr[num])\n    return result']",200,0.000848699826747179,0.0009081570012494922,0.0012095000129193068,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def funcImp(arr, k):\n    dict_arr = {}\n    for i in range(len(arr)):\n        dict_arr[arr[i]] = i\n    smallest_k = sorted(arr)[:k]\n    result = []\n    for num in smallest_k:\n        result.append(dict_arr[num])\n    return result']",300,0.0012175000738352537,0.0013244050065986813,0.001526400214061141,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def funcImp(arr, k):\n    dict_arr = {}\n    for i in range(len(arr)):\n        dict_arr[arr[i]] = i\n    smallest_k = sorted(arr)[:k]\n    result = []\n    for num in smallest_k:\n        result.append(dict_arr[num])\n    return result']",600,0.0026291999965906143,0.0028839590004645288,0.0033623999916017056,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    dictIndex = {}\n    for i in range(len(arr)):\n        dictIndex[i] = arr[i]\n    sortedDict = sorted(dictIndex.items(), key=lambda x: x[1])\n    kSmallestIndexes = []\n    for i in range(k):\n        kSmallestIndexes.append(sortedDict[i][0])\n    return kSmallestIndexes']",200,0.001550000160932541,0.0016551750083453954,0.0020955000072717667,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    dictIndex = {}\n    for i in range(len(arr)):\n        dictIndex[i] = arr[i]\n    sortedDict = sorted(dictIndex.items(), key=lambda x: x[1])\n    kSmallestIndexes = []\n    for i in range(k):\n        kSmallestIndexes.append(sortedDict[i][0])\n    return kSmallestIndexes']",300,0.002329000039026141,0.0024596530082635583,0.0027015998493880033,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    dictIndex = {}\n    for i in range(len(arr)):\n        dictIndex[i] = arr[i]\n    sortedDict = sorted(dictIndex.items(), key=lambda x: x[1])\n    kSmallestIndexes = []\n    for i in range(k):\n        kSmallestIndexes.append(sortedDict[i][0])\n    return kSmallestIndexes']",600,0.004945199936628342,0.005261361978482455,0.006183999823406339,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['def funcImp(arr, k):\n    index = {}\n    for i in range(len(arr)):\n        index[arr[i]] = i\n    smallest_k = sorted(arr)[:k]\n    result = []\n    for i in smallest_k:\n        result.append(index[i])\n    return result']",200,0.0008467999286949635,0.0008999020070768893,0.0010453998111188412,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['def funcImp(arr, k):\n    index = {}\n    for i in range(len(arr)):\n        index[arr[i]] = i\n    smallest_k = sorted(arr)[:k]\n    result = []\n    for i in smallest_k:\n        result.append(index[i])\n    return result']",300,0.0012631001882255077,0.0013363900082185864,0.001455900026485324,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"['def funcImp(arr, k):\n    index = {}\n    for i in range(len(arr)):\n        index[arr[i]] = i\n    smallest_k = sorted(arr)[:k]\n    result = []\n    for i in smallest_k:\n        result.append(index[i])\n    return result']",600,0.00268030003644526,0.0028776409942656758,0.0033743001986294985,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    index_dict = {}\n    for idx, val in enumerate(arr):\n        index_dict[idx] = val\n    sorted_dict = sorted(index_dict.items(), key=lambda x: x[1])\n    indexes = []\n    for i in range(k):\n        indexes.append(sorted_dict[i][0])\n    return indexes']",200,0.0015700000803917646,0.0016715720132924616,0.002081700135022402,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    index_dict = {}\n    for idx, val in enumerate(arr):\n        index_dict[idx] = val\n    sorted_dict = sorted(index_dict.items(), key=lambda x: x[1])\n    indexes = []\n    for i in range(k):\n        indexes.append(sorted_dict[i][0])\n    return indexes']",300,0.0023451000452041626,0.0024765860033221544,0.002899100072681904,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    index_dict = {}\n    for idx, val in enumerate(arr):\n        index_dict[idx] = val\n    sorted_dict = sorted(index_dict.items(), key=lambda x: x[1])\n    indexes = []\n    for i in range(k):\n        indexes.append(sorted_dict[i][0])\n    return indexes']",600,0.005062200129032135,0.005290209008380771,0.005722600035369396,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(lst, k):\n    heap = lst[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(lst)):\n        if lst[i] < heap[-1]:\n            heapq.heappushpop(heap, lst[i])\n    return [lst.index(x) for x in heap]']",200,0.0006744998972862959,0.0009373499802313745,0.001147200120612979,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(lst, k):\n    heap = lst[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(lst)):\n        if lst[i] < heap[-1]:\n            heapq.heappushpop(heap, lst[i])\n    return [lst.index(x) for x in heap]']",300,0.0008165999315679073,0.0013974329899065197,0.0017349999397993088,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(lst, k):\n    heap = lst[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(lst)):\n        if lst[i] < heap[-1]:\n            heapq.heappushpop(heap, lst[i])\n    return [lst.index(x) for x in heap]']",600,0.0017643000464886427,0.0027837819862179458,0.003416299819946289,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    index_list = []\n    kth_smallest = sorted(arr)[:k][-1]\n    for i in range(len(arr)):\n        if arr[i] <= kth_smallest:\n            index_list.append(i)\n            if len(index_list) == k:\n                break\n    return index_list']",200,0.0004757000133395195,0.0006087339972145855,0.0011760999914258718,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    index_list = []\n    kth_smallest = sorted(arr)[:k][-1]\n    for i in range(len(arr)):\n        if arr[i] <= kth_smallest:\n            index_list.append(i)\n            if len(index_list) == k:\n                break\n    return index_list']",300,0.00065660011023283,0.0009223469998687506,0.0012304000556468964,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    index_list = []\n    kth_smallest = sorted(arr)[:k][-1]\n    for i in range(len(arr)):\n        if arr[i] <= kth_smallest:\n            index_list.append(i)\n            if len(index_list) == k:\n                break\n    return index_list']",600,0.001301000127568841,0.0020062149805016817,0.0022929999977350235,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['import heapq\n\ndef funcImp(nums, k):\n    indexes = []\n    heap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(heap)\n    for _ in range(k):\n        num, i = heapq.heappop(heap)\n        indexes.append(i)\n    return indexes']",200,0.0009995000436902046,0.0010506029985845088,0.001313100103288889,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['import heapq\n\ndef funcImp(nums, k):\n    indexes = []\n    heap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(heap)\n    for _ in range(k):\n        num, i = heapq.heappop(heap)\n        indexes.append(i)\n    return indexes']",300,0.0014728999231010675,0.0015380240022204816,0.0018408999312669039,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['import heapq\n\ndef funcImp(nums, k):\n    indexes = []\n    heap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(heap)\n    for _ in range(k):\n        num, i = heapq.heappop(heap)\n        indexes.append(i)\n    return indexes']",600,0.003013900015503168,0.003126529997680336,0.0033348998986184597,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n    indexed_arr = [(num, i) for i, num in enumerate(arr)]\n    sorted_arr = sorted(indexed_arr, key=lambda x: x[0])\n    k_indices = [t[1] for t in sorted_arr[:k]]\n    return k_indices']",200,0.0014198001008480787,0.0016101839975453914,0.003388199955224991,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n    indexed_arr = [(num, i) for i, num in enumerate(arr)]\n    sorted_arr = sorted(indexed_arr, key=lambda x: x[0])\n    k_indices = [t[1] for t in sorted_arr[:k]]\n    return k_indices']",300,0.002130000153556466,0.002274216008372605,0.0025211002212017775,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n    indexed_arr = [(num, i) for i, num in enumerate(arr)]\n    sorted_arr = sorted(indexed_arr, key=lambda x: x[0])\n    k_indices = [t[1] for t in sorted_arr[:k]]\n    return k_indices']",600,0.004552399972453713,0.00488753299228847,0.005367999896407127,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"[""def funcImp(arr, k):\n    indexes = []\n    for i in range(k):\n        min_val = min(arr)\n        min_index = arr.index(min_val)\n        indexes.append(min_index)\n        arr[min_index] = float('inf')\n    return indexes""]",200,0.0008398001082241535,0.0008753089886158705,0.0011400999501347542,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"[""def funcImp(arr, k):\n    indexes = []\n    for i in range(k):\n        min_val = min(arr)\n        min_index = arr.index(min_val)\n        indexes.append(min_index)\n        arr[min_index] = float('inf')\n    return indexes""]",300,0.0014166000764817,0.0014668060094118118,0.0015774001367390156,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"[""def funcImp(arr, k):\n    indexes = []\n    for i in range(k):\n        min_val = min(arr)\n        min_index = arr.index(min_val)\n        indexes.append(min_index)\n        arr[min_index] = float('inf')\n    return indexes""]",600,0.0034543999936431646,0.003682354006450623,0.004067100118845701,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import heapq\n\ndef funcImp(arr, k):\n    heap = arr[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[-1]:\n            heapq.heappushpop(heap, arr[i])\n    indexes = []\n    for num in heap:\n        indexes.append(arr.index(num))\n    return indexes']",200,0.0006309000309556723,0.0009326140186749399,0.001173300202935934,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import heapq\n\ndef funcImp(arr, k):\n    heap = arr[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[-1]:\n            heapq.heappushpop(heap, arr[i])\n    indexes = []\n    for num in heap:\n        indexes.append(arr.index(num))\n    return indexes']",300,0.0008731000125408173,0.0013670790172182023,0.0016391000244766474,N/A
2_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['import heapq\n\ndef funcImp(arr, k):\n    heap = arr[:k]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[-1]:\n            heapq.heappushpop(heap, arr[i])\n    indexes = []\n    for num in heap:\n        indexes.append(arr.index(num))\n    return indexes']",600,0.002041799947619438,0.0027762390021234752,0.0033591000828891993,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def funcImp(lst, k):\n    """"""\n    This function takes a list of integers and an integer k as inputs,\n    and returns the indexes of the k smallest numbers in the list.\n    The implementation has a time complexity of O(n log k).\n    """"""\n    import heapq\n    heap = [(lst[i], i) for i in range(k)]\n    heapq._heapify_max(heap)\n    for i in range(k, len(lst)):\n        if lst[i] < heap[0][0]:\n            heapq._heapreplace_max(heap, (lst[i], i))\n    return [heapq.heappop(heap)[1] for _ in range(k)]']",200,0.0005619998555630445,0.0006672500073909759,0.0010053999722003937,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def funcImp(lst, k):\n    """"""\n    This function takes a list of integers and an integer k as inputs,\n    and returns the indexes of the k smallest numbers in the list.\n    The implementation has a time complexity of O(n log k).\n    """"""\n    import heapq\n    heap = [(lst[i], i) for i in range(k)]\n    heapq._heapify_max(heap)\n    for i in range(k, len(lst)):\n        if lst[i] < heap[0][0]:\n            heapq._heapreplace_max(heap, (lst[i], i))\n    return [heapq.heappop(heap)[1] for _ in range(k)]']",300,0.0008255001157522202,0.0009106050059199334,0.0010646998416632414,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",1,"['def funcImp(lst, k):\n    """"""\n    This function takes a list of integers and an integer k as inputs,\n    and returns the indexes of the k smallest numbers in the list.\n    The implementation has a time complexity of O(n log k).\n    """"""\n    import heapq\n    heap = [(lst[i], i) for i in range(k)]\n    heapq._heapify_max(heap)\n    for i in range(k, len(lst)):\n        if lst[i] < heap[0][0]:\n            heapq._heapreplace_max(heap, (lst[i], i))\n    return [heapq.heappop(heap)[1] for _ in range(k)]']",600,0.0015652000438421965,0.0016791890026070177,0.0018350000027567148,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    """"""\n    Returns the indexes of the k smallest numbers in an unsorted array.\n    """"""\n\n    def partition(arr, l, r):\n        pivot = arr[r]\n        i = l\n        for j in range(l, r):\n            if arr[j] <= pivot:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[r] = (arr[r], arr[i])\n        return i\n\n    def select(arr, l, r, k):\n        if l == r:\n            return l\n        pivotIndex = partition(arr, l, r)\n        if k == pivotIndex:\n            return k\n        elif k < pivotIndex:\n            return select(arr, l, pivotIndex - 1, k)\n        else:\n            return select(arr, pivotIndex + 1, r, k)\n    kth_smallest = arr[select(arr, 0, len(arr) - 1, k - 1)]\n    indexes = [i for i, x in enumerate(arr) if x <= kth_smallest][:k]\n    return indexes']",200,0.08379830000922084,0.08622294199187308,0.08918310003355145,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    """"""\n    Returns the indexes of the k smallest numbers in an unsorted array.\n    """"""\n\n    def partition(arr, l, r):\n        pivot = arr[r]\n        i = l\n        for j in range(l, r):\n            if arr[j] <= pivot:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[r] = (arr[r], arr[i])\n        return i\n\n    def select(arr, l, r, k):\n        if l == r:\n            return l\n        pivotIndex = partition(arr, l, r)\n        if k == pivotIndex:\n            return k\n        elif k < pivotIndex:\n            return select(arr, l, pivotIndex - 1, k)\n        else:\n            return select(arr, pivotIndex + 1, r, k)\n    kth_smallest = arr[select(arr, 0, len(arr) - 1, k - 1)]\n    indexes = [i for i, x in enumerate(arr) if x <= kth_smallest][:k]\n    return indexes']",300,0.18216619989834726,0.18773176899412647,0.19455299992114305,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",2,"['def funcImp(arr, k):\n    """"""\n    Returns the indexes of the k smallest numbers in an unsorted array.\n    """"""\n\n    def partition(arr, l, r):\n        pivot = arr[r]\n        i = l\n        for j in range(l, r):\n            if arr[j] <= pivot:\n                arr[i], arr[j] = (arr[j], arr[i])\n                i += 1\n        arr[i], arr[r] = (arr[r], arr[i])\n        return i\n\n    def select(arr, l, r, k):\n        if l == r:\n            return l\n        pivotIndex = partition(arr, l, r)\n        if k == pivotIndex:\n            return k\n        elif k < pivotIndex:\n            return select(arr, l, pivotIndex - 1, k)\n        else:\n            return select(arr, pivotIndex + 1, r, k)\n    kth_smallest = arr[select(arr, 0, len(arr) - 1, k - 1)]\n    indexes = [i for i, x in enumerate(arr) if x <= kth_smallest][:k]\n    return indexes']",600,0.731271900003776,0.7499115190003067,0.7803263000678271,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"[""def funcImp(arr, k):\n\n    def select(left, right, k_smallest):\n        if left == right:\n            return arr[left]\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(left, right, pivot_index)\n        if k_smallest == pivot_index:\n            return arr[k_smallest]\n        elif k_smallest < pivot_index:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n\n    def partition(left, right, pivot_index):\n        pivot_value = arr[pivot_index]\n        arr[pivot_index], arr[right] = (arr[right], arr[pivot_index])\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot_value:\n                arr[store_index], arr[i] = (arr[i], arr[store_index])\n                store_index += 1\n        arr[right], arr[store_index] = (arr[store_index], arr[right])\n        return store_index\n    if k > len(arr):\n        return 'k is greater than length of array'\n    k_smallest = k - 1\n    return select(0, len(arr) - 1, k_smallest)""]",200,0.0014648002106696367,0.0016801699949428438,0.0019578998908400536,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"[""def funcImp(arr, k):\n\n    def select(left, right, k_smallest):\n        if left == right:\n            return arr[left]\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(left, right, pivot_index)\n        if k_smallest == pivot_index:\n            return arr[k_smallest]\n        elif k_smallest < pivot_index:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n\n    def partition(left, right, pivot_index):\n        pivot_value = arr[pivot_index]\n        arr[pivot_index], arr[right] = (arr[right], arr[pivot_index])\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot_value:\n                arr[store_index], arr[i] = (arr[i], arr[store_index])\n                store_index += 1\n        arr[right], arr[store_index] = (arr[store_index], arr[right])\n        return store_index\n    if k > len(arr):\n        return 'k is greater than length of array'\n    k_smallest = k - 1\n    return select(0, len(arr) - 1, k_smallest)""]",300,0.0019838002044707537,0.00231798600172624,0.00276739988476038,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",3,"[""def funcImp(arr, k):\n\n    def select(left, right, k_smallest):\n        if left == right:\n            return arr[left]\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(left, right, pivot_index)\n        if k_smallest == pivot_index:\n            return arr[k_smallest]\n        elif k_smallest < pivot_index:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n\n    def partition(left, right, pivot_index):\n        pivot_value = arr[pivot_index]\n        arr[pivot_index], arr[right] = (arr[right], arr[pivot_index])\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot_value:\n                arr[store_index], arr[i] = (arr[i], arr[store_index])\n                store_index += 1\n        arr[right], arr[store_index] = (arr[store_index], arr[right])\n        return store_index\n    if k > len(arr):\n        return 'k is greater than length of array'\n    k_smallest = k - 1\n    return select(0, len(arr) - 1, k_smallest)""]",600,0.00362580013461411,0.004291418010834605,0.004861900117248297,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    arrSorted = sorted(arr)\n    smallestK = arrSorted[:k]\n    indexDict = {}\n    for i in range(len(arr)):\n        if arr[i] in smallestK:\n            indexDict[arr[i]] = i\n            smallestK.remove(arr[i])\n            if len(indexDict) == k:\n                break\n    return [indexDict[x] for x in sorted(indexDict.keys())]']",200,0.000604500062763691,0.0008448599954135716,0.0010983000975102186,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    arrSorted = sorted(arr)\n    smallestK = arrSorted[:k]\n    indexDict = {}\n    for i in range(len(arr)):\n        if arr[i] in smallestK:\n            indexDict[arr[i]] = i\n            smallestK.remove(arr[i])\n            if len(indexDict) == k:\n                break\n    return [indexDict[x] for x in sorted(indexDict.keys())]']",300,0.000826000003144145,0.0012180439964868128,0.001590800005942583,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",4,"['def funcImp(arr, k):\n    arrSorted = sorted(arr)\n    smallestK = arrSorted[:k]\n    indexDict = {}\n    for i in range(len(arr)):\n        if arr[i] in smallestK:\n            indexDict[arr[i]] = i\n            smallestK.remove(arr[i])\n            if len(indexDict) == k:\n                break\n    return [indexDict[x] for x in sorted(indexDict.keys())]']",600,0.0019176998175680637,0.0026252280012704432,0.003053099848330021,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return [heapq.heappop(heap)[1] for i in range(k)]']",200,0.0004934999160468578,0.0005763060133904219,0.0007297000847756863,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return [heapq.heappop(heap)[1] for i in range(k)]']",300,0.0007255000527948141,0.000805759986396879,0.001156599959358573,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",5,"['import heapq\n\ndef funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[0][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return [heapq.heappop(heap)[1] for i in range(k)]']",600,0.001430500065907836,0.001547585993539542,0.0017114998772740364,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    """"""\n        Find the indexes of the k smallest numbers in an unsorted array arr\n        \n        Parameters:\n            arr (List[int]): Unsorted array \n            k (int): Number of smallest indexes to find\n            \n        Returns: \n            indexes (List[int]): Indexes of the k smallest numbers in the array\n    """"""\n    smallest = sorted(arr)[:k]\n    indexes = {}\n    for i in range(len(arr)):\n        if arr[i] in smallest:\n            indexes[arr[i]] = i\n    sorted_indexes = [indexes[x] for x in smallest]\n    return sorted_indexes']",200,0.0009234000463038683,0.0009903729986399411,0.0011778001207858324,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    """"""\n        Find the indexes of the k smallest numbers in an unsorted array arr\n        \n        Parameters:\n            arr (List[int]): Unsorted array \n            k (int): Number of smallest indexes to find\n            \n        Returns: \n            indexes (List[int]): Indexes of the k smallest numbers in the array\n    """"""\n    smallest = sorted(arr)[:k]\n    indexes = {}\n    for i in range(len(arr)):\n        if arr[i] in smallest:\n            indexes[arr[i]] = i\n    sorted_indexes = [indexes[x] for x in smallest]\n    return sorted_indexes']",300,0.0014254001434892416,0.0014750810130499303,0.001846899976953864,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",6,"['def funcImp(arr, k):\n    """"""\n        Find the indexes of the k smallest numbers in an unsorted array arr\n        \n        Parameters:\n            arr (List[int]): Unsorted array \n            k (int): Number of smallest indexes to find\n            \n        Returns: \n            indexes (List[int]): Indexes of the k smallest numbers in the array\n    """"""\n    smallest = sorted(arr)[:k]\n    indexes = {}\n    for i in range(len(arr)):\n        if arr[i] in smallest:\n            indexes[arr[i]] = i\n    sorted_indexes = [indexes[x] for x in smallest]\n    return sorted_indexes']",600,0.002973299939185381,0.0031620209850370886,0.0034896000288426876,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['def funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[-1][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return [x[1] for x in sorted(heap)]']",200,0.0008197999559342861,0.001854336995165795,0.002648900030180812,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['def funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[-1][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return [x[1] for x in sorted(heap)]']",300,0.0011160001158714294,0.002682686997577548,0.003877100069075823,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",7,"['def funcImp(arr, k):\n    heap = [(arr[i], i) for i in range(k)]\n    heapq.heapify(heap)\n    for i in range(k, len(arr)):\n        if arr[i] < heap[-1][0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (arr[i], i))\n    return [x[1] for x in sorted(heap)]']",600,0.0024176998995244503,0.005511560996528715,0.008170999819412827,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n\n    def partition(l, r):\n        pivot = arr[r]\n        i = l - 1\n        for j in range(l, r):\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = (arr[j], arr[i])\n        arr[i + 1], arr[r] = (arr[r], arr[i + 1])\n        return i + 1\n\n    def quickselect(l, r, k_smallest):\n        if l == r:\n            return arr[l]\n        pivot_index = partition(l, r)\n        if k_smallest == pivot_index:\n            return arr[k_smallest]\n        elif k_smallest < pivot_index:\n            return quickselect(l, pivot_index - 1, k_smallest)\n        else:\n            return quickselect(pivot_index + 1, r, k_smallest)\n    if k < 1 or k > len(arr):\n        return []\n    k_smallest = k - 1\n    return [quickselect(0, len(arr) - 1, i) for i in range(k_smallest + 1)]']",200,0.4084296999499202,0.4504427819955163,0.49560120003297925,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n\n    def partition(l, r):\n        pivot = arr[r]\n        i = l - 1\n        for j in range(l, r):\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = (arr[j], arr[i])\n        arr[i + 1], arr[r] = (arr[r], arr[i + 1])\n        return i + 1\n\n    def quickselect(l, r, k_smallest):\n        if l == r:\n            return arr[l]\n        pivot_index = partition(l, r)\n        if k_smallest == pivot_index:\n            return arr[k_smallest]\n        elif k_smallest < pivot_index:\n            return quickselect(l, pivot_index - 1, k_smallest)\n        else:\n            return quickselect(pivot_index + 1, r, k_smallest)\n    if k < 1 or k > len(arr):\n        return []\n    k_smallest = k - 1\n    return [quickselect(0, len(arr) - 1, i) for i in range(k_smallest + 1)]']",300,0.9472324999514967,1.00371865299996,1.1038864001166075,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",8,"['def funcImp(arr, k):\n\n    def partition(l, r):\n        pivot = arr[r]\n        i = l - 1\n        for j in range(l, r):\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = (arr[j], arr[i])\n        arr[i + 1], arr[r] = (arr[r], arr[i + 1])\n        return i + 1\n\n    def quickselect(l, r, k_smallest):\n        if l == r:\n            return arr[l]\n        pivot_index = partition(l, r)\n        if k_smallest == pivot_index:\n            return arr[k_smallest]\n        elif k_smallest < pivot_index:\n            return quickselect(l, pivot_index - 1, k_smallest)\n        else:\n            return quickselect(pivot_index + 1, r, k_smallest)\n    if k < 1 or k > len(arr):\n        return []\n    k_smallest = k - 1\n    return [quickselect(0, len(arr) - 1, i) for i in range(k_smallest + 1)]']",600,4.00708799995482,4.120808645996731,4.415623800130561,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(arr, k):\n    if k <= 0:\n        return []\n    if k >= len(arr):\n        return [i for i in range(len(arr))]\n    indices = [i for i in range(k)]\n    indices.sort(key=lambda i: -arr[i])\n    for i in range(k, len(arr)):\n        if arr[i] < arr[indices[0]]:\n            indices[0] = i\n            indices.sort(key=lambda i: -arr[i])\n    return indices']",200,0.0007568998262286186,0.001062535005621612,0.0016127999406307936,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(arr, k):\n    if k <= 0:\n        return []\n    if k >= len(arr):\n        return [i for i in range(len(arr))]\n    indices = [i for i in range(k)]\n    indices.sort(key=lambda i: -arr[i])\n    for i in range(k, len(arr)):\n        if arr[i] < arr[indices[0]]:\n            indices[0] = i\n            indices.sort(key=lambda i: -arr[i])\n    return indices']",300,0.0010098000057041645,0.001307913006749004,0.0016151000745594501,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",9,"['def funcImp(arr, k):\n    if k <= 0:\n        return []\n    if k >= len(arr):\n        return [i for i in range(len(arr))]\n    indices = [i for i in range(k)]\n    indices.sort(key=lambda i: -arr[i])\n    for i in range(k, len(arr)):\n        if arr[i] < arr[indices[0]]:\n            indices[0] = i\n            indices.sort(key=lambda i: -arr[i])\n    return indices']",600,0.0018249999266117811,0.0020945829921402035,0.002678799908608198,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['def funcImp(arr, k):\n    indexes = []\n    for i in range(k):\n        min_index = i\n        for j in range(i + 1, len(arr)):\n            if arr[min_index] > arr[j]:\n                min_index = j\n        indexes.append(min_index)\n        arr[i], arr[min_index] = (arr[min_index], arr[i])\n    return indexes']",200,0.001628299942240119,0.0017712559993378818,0.002169900108128786,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['def funcImp(arr, k):\n    indexes = []\n    for i in range(k):\n        min_index = i\n        for j in range(i + 1, len(arr)):\n            if arr[min_index] > arr[j]:\n                min_index = j\n        indexes.append(min_index)\n        arr[i], arr[min_index] = (arr[min_index], arr[i])\n    return indexes']",300,0.0025140000507235527,0.0026724360161460934,0.0032417001202702522,N/A
3_p3_auto_find_duplicates_list_strategy,"""Python algorithm to find the indexes of the k smallest number in an unsorted array? The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers and k smallest number as a parameters.""",10,"['def funcImp(arr, k):\n    indexes = []\n    for i in range(k):\n        min_index = i\n        for j in range(i + 1, len(arr)):\n            if arr[min_index] > arr[j]:\n                min_index = j\n        indexes.append(min_index)\n        arr[i], arr[min_index] = (arr[min_index], arr[i])\n    return indexes']",600,0.005352099891752005,0.0056287529948167506,0.006739300210028887,N/A
