function_index,prompt,sample_index,code_segment,Size,Min,Average,Max,Exception
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    if num_rows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        curr_row = [1]\n        for j in range(1, i):\n            curr_row.append(prev_row[j - 1] + prev_row[j])\n        curr_row.append(1)\n        triangle.append(curr_row)\n    return triangle']",1000,0.01917769992724061,0.019830380000639705,0.020923800067976117,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    if num_rows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        curr_row = [1]\n        for j in range(1, i):\n            curr_row.append(prev_row[j - 1] + prev_row[j])\n        curr_row.append(1)\n        triangle.append(curr_row)\n    return triangle']",10000,0.018925299867987633,0.019746922014746815,0.020654299994930625,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    if num_rows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        curr_row = [1]\n        for j in range(1, i):\n            curr_row.append(prev_row[j - 1] + prev_row[j])\n        curr_row.append(1)\n        triangle.append(curr_row)\n    return triangle']",1000000,0.018842800054699183,0.01978315699612722,0.021326499991118908,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(n):\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.026227000169456005,0.02783944401424378,0.02994629996828735,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(n):\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.026646000100299716,0.027927491003647446,0.031077200081199408,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(n):\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.02658760012127459,0.027957602017559112,0.029676000121980906,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000,0.025042399996891618,0.026416929999832063,0.028118500020354986,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",10000,0.025200099917128682,0.026279367986135185,0.027892100159078836,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000000,0.024444099981337786,0.026257499994244426,0.028806899907067418,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['from typing import List\n\ndef funcImp(num_rows: int) -> List[List[int]]:\n    """"""\n    Generates Pascal\'s Triangle.\n    :param num_rows: Input number of rows.\n    :return: 2D list of integers representing Pascal\'s Triangle.\n    """"""\n    triangle = []\n    for row_num in range(num_rows):\n        row = [None for _ in range(row_num + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle']",1000,0.03045630012638867,0.031955939016770574,0.03333880007266998,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['from typing import List\n\ndef funcImp(num_rows: int) -> List[List[int]]:\n    """"""\n    Generates Pascal\'s Triangle.\n    :param num_rows: Input number of rows.\n    :return: 2D list of integers representing Pascal\'s Triangle.\n    """"""\n    triangle = []\n    for row_num in range(num_rows):\n        row = [None for _ in range(row_num + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle']",10000,0.03036270011216402,0.03203535500215367,0.035169299924746156,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['from typing import List\n\ndef funcImp(num_rows: int) -> List[List[int]]:\n    """"""\n    Generates Pascal\'s Triangle.\n    :param num_rows: Input number of rows.\n    :return: 2D list of integers representing Pascal\'s Triangle.\n    """"""\n    triangle = []\n    for row_num in range(num_rows):\n        row = [None for _ in range(row_num + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle']",1000000,0.030512299854308367,0.031998442001640794,0.03334470000118017,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    pascal_triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            value = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n            row.append(value)\n        row.append(1)\n        pascal_triangle.append(row)\n    return pascal_triangle']",1000,0.027689100010320544,0.02923164400504902,0.03263509995304048,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    pascal_triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            value = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n            row.append(value)\n        row.append(1)\n        pascal_triangle.append(row)\n    return pascal_triangle']",10000,0.027660700026899576,0.029261226987000555,0.03215969982556999,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    pascal_triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            value = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n            row.append(value)\n        row.append(1)\n        pascal_triangle.append(row)\n    return pascal_triangle']",1000000,0.02707220008596778,0.029391018010210247,0.03292719996534288,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,['def funcImp(rows):\n    triangle = []\n    for i in range(rows):\n        row = [1]\n        if i > 0:\n            prev_row = triangle[-1]\n            for j in range(len(prev_row) - 1):\n                row.append(prev_row[j] + prev_row[j + 1])\n        row.append(1)\n        triangle.append(row)\n    return triangle'],1000,0.019478200003504753,0.020256910000462085,0.02347190002910793,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,['def funcImp(rows):\n    triangle = []\n    for i in range(rows):\n        row = [1]\n        if i > 0:\n            prev_row = triangle[-1]\n            for j in range(len(prev_row) - 1):\n                row.append(prev_row[j] + prev_row[j + 1])\n        row.append(1)\n        triangle.append(row)\n    return triangle'],10000,0.019534800201654434,0.02029417899204418,0.024045899976044893,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,['def funcImp(rows):\n    triangle = []\n    for i in range(rows):\n        row = [1]\n        if i > 0:\n            prev_row = triangle[-1]\n            for j in range(len(prev_row) - 1):\n                row.append(prev_row[j] + prev_row[j + 1])\n        row.append(1)\n        triangle.append(row)\n    return triangle'],1000000,0.019380199955776334,0.02041789799230173,0.022026299964636564,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle[:num_rows]']",1000,0.025706399930641055,0.027765132000204175,0.02970820013433695,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle[:num_rows]']",10000,0.026237099897116423,0.02802502899663523,0.03692079987376928,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle[:num_rows]']",1000000,0.02621199982240796,0.027771720006130637,0.032462900038808584,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prev_row = triangle[-1]\n        new_row = [1] + [prev_row[j] + prev_row[j + 1] for j in range(len(prev_row) - 1)] + [1]\n        triangle.append(new_row)\n    return triangle']",1000,0.01948149991221726,0.020465170983225107,0.022658900124952197,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prev_row = triangle[-1]\n        new_row = [1] + [prev_row[j] + prev_row[j + 1] for j in range(len(prev_row) - 1)] + [1]\n        triangle.append(new_row)\n    return triangle']",10000,0.019414199981838465,0.020398877006955446,0.02484810003079474,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prev_row = triangle[-1]\n        new_row = [1] + [prev_row[j] + prev_row[j + 1] for j in range(len(prev_row) - 1)] + [1]\n        triangle.append(new_row)\n    return triangle']",1000000,0.01934560015797615,0.02021489300997928,0.021312700118869543,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(n):\n    triangle = [[1] * (i + 1) for i in range(n)]\n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",1000,0.026867599925026298,0.028322636012453585,0.03245180007070303,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(n):\n    triangle = [[1] * (i + 1) for i in range(n)]\n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",10000,0.026959799928590655,0.02830066201277077,0.03021900006569922,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(n):\n    triangle = [[1] * (i + 1) for i in range(n)]\n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",1000000,0.02630379982292652,0.02832573600113392,0.032896799966692924,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.026237000012770295,0.02786438597831875,0.0308808998670429,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.025706299813464284,0.02778777798637748,0.029005299787968397,N/A
0_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.025794100016355515,0.027637459002435208,0.030683200107887387,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        cur_row = [1]\n        for j in range(1, i):\n            cur_row.append(prev_row[j - 1] + prev_row[j])\n        cur_row.append(1)\n        triangle.append(cur_row)\n    return triangle']",1000,0.018817299976944923,0.019687853988725693,0.020866000093519688,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        cur_row = [1]\n        for j in range(1, i):\n            cur_row.append(prev_row[j - 1] + prev_row[j])\n        cur_row.append(1)\n        triangle.append(cur_row)\n    return triangle']",10000,0.018760900013148785,0.019642948000691832,0.020858800038695335,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        cur_row = [1]\n        for j in range(1, i):\n            cur_row.append(prev_row[j - 1] + prev_row[j])\n        cur_row.append(1)\n        triangle.append(cur_row)\n    return triangle']",1000000,0.018632400082424283,0.019721628990955652,0.022233299911022186,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(num_rows):\n    if num_rows == 0:\n        return []\n    pt = [[1]]\n    for i in range(1, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(pt[i - 1][j - 1] + pt[i - 1][j])\n        row.append(1)\n        pt.append(row)\n    return pt']",1000,0.026272199815139174,0.027734552996698768,0.02939899987541139,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(num_rows):\n    if num_rows == 0:\n        return []\n    pt = [[1]]\n    for i in range(1, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(pt[i - 1][j - 1] + pt[i - 1][j])\n        row.append(1)\n        pt.append(row)\n    return pt']",10000,0.02621969999745488,0.02791615400929004,0.031233600107952952,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(num_rows):\n    if num_rows == 0:\n        return []\n    pt = [[1]]\n    for i in range(1, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(pt[i - 1][j - 1] + pt[i - 1][j])\n        row.append(1)\n        pt.append(row)\n    return pt']",1000000,0.02651169989258051,0.02793113101273775,0.032841800013557076,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = [[1] * (i + 1) for i in range(numRows)]\n    for i in range(2, numRows):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",1000,0.026396000059321523,0.02826769698644057,0.0311296998988837,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = [[1] * (i + 1) for i in range(numRows)]\n    for i in range(2, numRows):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",10000,0.02675620000809431,0.028443457996472715,0.03332000016234815,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = [[1] * (i + 1) for i in range(numRows)]\n    for i in range(2, numRows):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",1000000,0.02671030000783503,0.028837465993128718,0.044331599958240986,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    if num_rows == 1:\n        return [1]\n    elif num_rows == 2:\n        return triangle\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            element = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            row.append(element)\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.027712199836969376,0.0294784779753536,0.03549959999509156,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    if num_rows == 1:\n        return [1]\n    elif num_rows == 2:\n        return triangle\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            element = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            row.append(element)\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.028146799886599183,0.02952468900475651,0.0332114000339061,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    if num_rows == 1:\n        return [1]\n    elif num_rows == 2:\n        return triangle\n    for i in range(2, num_rows):\n        row = [1]\n        for j in range(1, i):\n            element = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            row.append(element)\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.02783169993199408,0.029434134017210452,0.03156289993785322,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000,0.02396510005928576,0.025687625990249218,0.03470000019297004,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",10000,0.024445899995043874,0.025421198001131417,0.026839500060305,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000000,0.023943800013512373,0.025493220009375362,0.027409099973738194,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.026438400149345398,0.02763670600950718,0.029629499884322286,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.026099100010469556,0.027785464993212373,0.029692100128158927,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.026168900076299906,0.027889798989053815,0.029888400109484792,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(rows):\n    triangle = []\n    for i in range(rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000,0.02408230002038181,0.025500511997379363,0.027354600140824914,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(rows):\n    triangle = []\n    for i in range(rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",10000,0.024453300051391125,0.02551186499418691,0.026842299848794937,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(rows):\n    triangle = []\n    for i in range(rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000000,0.024041200056672096,0.02553457998437807,0.026979299960657954,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(rows):\n    triangle = [[1]]\n    for i in range(1, rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.026225899811834097,0.028314600999001415,0.04555889987386763,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(rows):\n    triangle = [[1]]\n    for i in range(1, rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.026000400073826313,0.027861865006852896,0.029829700011759996,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(rows):\n    triangle = [[1]]\n    for i in range(1, rows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.025642000138759613,0.027830085011664778,0.031187399988994002,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        if i > 0:\n            row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.026006200117990375,0.027702045002952216,0.02941560000181198,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        if i > 0:\n            row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.026502700056880713,0.027845826994162052,0.02976069995202124,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        if i > 0:\n            row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.02611920004710555,0.027648730003274977,0.029339100001379848,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(num_rows):\n    res = []\n    for i in range(num_rows):\n        row = [None for _ in range(i + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = res[i - 1][j - 1] + res[i - 1][j]\n        res.append(row)\n    return res']",1000,0.03053139988332987,0.031804110987577586,0.033324799966067076,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(num_rows):\n    res = []\n    for i in range(num_rows):\n        row = [None for _ in range(i + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = res[i - 1][j - 1] + res[i - 1][j]\n        res.append(row)\n    return res']",10000,0.03062770003452897,0.0319191649928689,0.03377039986662567,N/A
1_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(num_rows):\n    res = []\n    for i in range(num_rows):\n        row = [None for _ in range(i + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = res[i - 1][j - 1] + res[i - 1][j]\n        res.append(row)\n    return res']",1000000,0.030858299927785993,0.032129802000708876,0.03722240007482469,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.02656959998421371,0.027781523999292405,0.029284500051289797,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.02643060008995235,0.027764212004840375,0.02949719992466271,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.026440100045874715,0.027889033989049496,0.032236000057309866,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(rows):\n    triangle = []\n    for row in range(rows):\n        row_list = [1]\n        for column in range(1, row + 1):\n            value = row_list[column - 1] * (row - column + 1) // column\n            row_list.append(value)\n        triangle.append(row_list)\n    return triangle']",1000,0.03447740012779832,0.036079292008653285,0.06506350007839501,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(rows):\n    triangle = []\n    for row in range(rows):\n        row_list = [1]\n        for column in range(1, row + 1):\n            value = row_list[column - 1] * (row - column + 1) // column\n            row_list.append(value)\n        triangle.append(row_list)\n    return triangle']",10000,0.03454359993338585,0.036067668001633135,0.049200500128790736,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(rows):\n    triangle = []\n    for row in range(rows):\n        row_list = [1]\n        for column in range(1, row + 1):\n            value = row_list[column - 1] * (row - column + 1) // column\n            row_list.append(value)\n        triangle.append(row_list)\n    return triangle']",1000000,0.034136899979785085,0.03578540201066062,0.03922699997201562,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,['def funcImp(numRows):\n    pascal = []\n    for i in range(numRows):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                prev_row = pascal[i - 1]\n                val = prev_row[j - 1] + prev_row[j]\n                row.append(val)\n        pascal.append(row)\n    return pascal'],1000,0.03281670017167926,0.03556343502830714,0.037173200165852904,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,['def funcImp(numRows):\n    pascal = []\n    for i in range(numRows):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                prev_row = pascal[i - 1]\n                val = prev_row[j - 1] + prev_row[j]\n                row.append(val)\n        pascal.append(row)\n    return pascal'],10000,0.03394800005480647,0.035588359015528113,0.03747290000319481,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,['def funcImp(numRows):\n    pascal = []\n    for i in range(numRows):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                prev_row = pascal[i - 1]\n                val = prev_row[j - 1] + prev_row[j]\n                row.append(val)\n        pascal.append(row)\n    return pascal'],1000000,0.033281799871474504,0.03551810198929161,0.038668999914079905,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [None for _ in range(i + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000,0.03078919998370111,0.03233601499116048,0.038633199874311686,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [None for _ in range(i + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",10000,0.030797700164839625,0.03219397600274533,0.035667299991473556,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [None for _ in range(i + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle']",1000000,0.0304324000608176,0.032074668996501715,0.033791900146752596,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = []\n    for row_num in range(num_rows):\n        row = [None for _ in range(row_num + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle']",1000,0.03075390006415546,0.03188382098916918,0.03520549996756017,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = []\n    for row_num in range(num_rows):\n        row = [None for _ in range(row_num + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle']",10000,0.03060860000550747,0.03183835499221459,0.035381400026381016,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = []\n    for row_num in range(num_rows):\n        row = [None for _ in range(row_num + 1)]\n        row[0], row[-1] = (1, 1)\n        for j in range(1, len(row) - 1):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle']",1000000,0.03060850012116134,0.03174971499480307,0.03413769998587668,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(numRows):\n    triangle = []\n    if numRows == 0:\n        return triangle\n    first_row = [1]\n    triangle.append(first_row)\n    for i in range(1, numRows):\n        prev_row = triangle[i - 1]\n        row = []\n        row.append(1)\n        for j in range(1, i):\n            row.append(prev_row[j - 1] + prev_row[j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.018604899989441037,0.019593725006561726,0.02172790002077818,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(numRows):\n    triangle = []\n    if numRows == 0:\n        return triangle\n    first_row = [1]\n    triangle.append(first_row)\n    for i in range(1, numRows):\n        prev_row = triangle[i - 1]\n        row = []\n        row.append(1)\n        for j in range(1, i):\n            row.append(prev_row[j - 1] + prev_row[j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.018525700084865093,0.019636326001491396,0.021568900207057595,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(numRows):\n    triangle = []\n    if numRows == 0:\n        return triangle\n    first_row = [1]\n    triangle.append(first_row)\n    for i in range(1, numRows):\n        prev_row = triangle[i - 1]\n        row = []\n        row.append(1)\n        for j in range(1, i):\n            row.append(prev_row[j - 1] + prev_row[j])\n        row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.018797999946400523,0.019558339996729047,0.02340370020829141,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(rows):\n    results = []\n    for i in range(rows):\n        row = []\n        for j in range(0, i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(results[i - 1][j - 1] + results[i - 1][j])\n        results.append(row)\n    return results']",1000,0.031763500068336725,0.03317613999824971,0.03551380010321736,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(rows):\n    results = []\n    for i in range(rows):\n        row = []\n        for j in range(0, i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(results[i - 1][j - 1] + results[i - 1][j])\n        results.append(row)\n    return results']",10000,0.03206830006092787,0.0331828129850328,0.034477900015190244,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(rows):\n    results = []\n    for i in range(rows):\n        row = []\n        for j in range(0, i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(results[i - 1][j - 1] + results[i - 1][j])\n        results.append(row)\n    return results']",1000000,0.032066999934613705,0.03341508898185566,0.037658299785107374,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(numRows):\n    res = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(res[i - 1][j - 1] + res[i - 1][j])\n        row.append(1)\n        res.append(row)\n    return res']",1000,0.025897299870848656,0.02800184900406748,0.029935300117358565,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(numRows):\n    res = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(res[i - 1][j - 1] + res[i - 1][j])\n        row.append(1)\n        res.append(row)\n    return res']",10000,0.02669509989209473,0.02803711500018835,0.04141209996305406,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(numRows):\n    res = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        for j in range(1, i):\n            row.append(res[i - 1][j - 1] + res[i - 1][j])\n        row.append(1)\n        res.append(row)\n    return res']",1000000,0.026858799858018756,0.028240945998113602,0.035733999917283654,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,['def funcImp(n):\n    triangle = []\n    for i in range(n):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    return triangle'],1000,0.032142699928954244,0.0335528489924036,0.03566440008580685,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,['def funcImp(n):\n    triangle = []\n    for i in range(n):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    return triangle'],10000,0.032160199945792556,0.033639597992878405,0.03697500005364418,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,['def funcImp(n):\n    triangle = []\n    for i in range(n):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    return triangle'],1000000,0.03202929999679327,0.03343880999833346,0.0376176000572741,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    for row in triangle:\n        print(row)'],1000,3.1682961999904364,3.2765344389993696,3.510828800033778,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    for row in triangle:\n        print(row)'],10000,3.161595200188458,3.3163572399970143,3.770522200036794,N/A
2_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,['def funcImp(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    for row in triangle:\n        print(row)'],1000000,3.2332412998657674,3.39702939099865,3.9613250999245793,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    triangle = []\n    for i in range(num_rows):\n        row = [1]\n        for j in range(1, i):\n            value = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            row.append(value)\n        if i > 0:\n            row.append(1)\n        triangle.append(row)\n    return triangle']",1000,0.027910200180485845,0.029488423001021148,0.03265510010533035,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    triangle = []\n    for i in range(num_rows):\n        row = [1]\n        for j in range(1, i):\n            value = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            row.append(value)\n        if i > 0:\n            row.append(1)\n        triangle.append(row)\n    return triangle']",10000,0.027891899924725294,0.029397580004297198,0.032884899992495775,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",1,"['def funcImp(num_rows):\n    triangle = []\n    for i in range(num_rows):\n        row = [1]\n        for j in range(1, i):\n            value = triangle[i - 1][j - 1] + triangle[i - 1][j]\n            row.append(value)\n        if i > 0:\n            row.append(1)\n        triangle.append(row)\n    return triangle']",1000000,0.027903000125661492,0.029476725009735673,0.040787299862131476,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prev_row = triangle[-1]\n        curr_row = [1]\n        for j in range(1, i):\n            curr_row.append(prev_row[j - 1] + prev_row[j])\n        curr_row.append(1)\n        triangle.append(curr_row)\n    return triangle']",1000,0.018821700010448694,0.01973958100890741,0.0330676999874413,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prev_row = triangle[-1]\n        curr_row = [1]\n        for j in range(1, i):\n            curr_row.append(prev_row[j - 1] + prev_row[j])\n        curr_row.append(1)\n        triangle.append(curr_row)\n    return triangle']",10000,0.018820099998265505,0.019762300993315874,0.02292790007777512,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",2,"['def funcImp(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prev_row = triangle[-1]\n        curr_row = [1]\n        for j in range(1, i):\n            curr_row.append(prev_row[j - 1] + prev_row[j])\n        curr_row.append(1)\n        triangle.append(curr_row)\n    return triangle']",1000000,0.018608399899676442,0.019821904003620147,0.023779200157150626,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = [[1] * (i + 1) for i in range(numRows)]\n    for i in range(numRows):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",1000,0.026891499990597367,0.02871511799748987,0.044297700049355626,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = [[1] * (i + 1) for i in range(numRows)]\n    for i in range(numRows):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",10000,0.02684239996597171,0.02833046100800857,0.03132529999129474,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",3,"['def funcImp(numRows):\n    triangle = [[1] * (i + 1) for i in range(numRows)]\n    for i in range(numRows):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n    return triangle']",1000000,0.02709099999628961,0.028440248020924628,0.03060840000398457,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prevRow = triangle[-1]\n        newRow = [1]\n        for j in range(1, i):\n            newRow.append(prevRow[j - 1] + prevRow[j])\n        newRow.append(1)\n        triangle.append(newRow)\n    return triangle']",1000,0.01913499995134771,0.019862033997196705,0.02090659993700683,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prevRow = triangle[-1]\n        newRow = [1]\n        for j in range(1, i):\n            newRow.append(prevRow[j - 1] + prevRow[j])\n        newRow.append(1)\n        triangle.append(newRow)\n    return triangle']",10000,0.01896539982408285,0.01978223698679358,0.021513199899345636,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",4,"['def funcImp(numRows):\n    triangle = [[1]]\n    for i in range(1, numRows):\n        prevRow = triangle[-1]\n        newRow = [1]\n        for j in range(1, i):\n            newRow.append(prevRow[j - 1] + prevRow[j])\n        newRow.append(1)\n        triangle.append(newRow)\n    return triangle']",1000000,0.018898900132626295,0.01983068102505058,0.021458800183609128,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1, 1]\n        for j in range(1, i):\n            row.insert(j, triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    return triangle[:num_rows]']",1000,0.029865499818697572,0.03118090797914192,0.0344542998354882,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1, 1]\n        for j in range(1, i):\n            row.insert(j, triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    return triangle[:num_rows]']",10000,0.03004720015451312,0.031195708001032472,0.03277739998884499,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",5,"['def funcImp(num_rows):\n    triangle = [[1], [1, 1]]\n    for i in range(2, num_rows):\n        row = [1, 1]\n        for j in range(1, i):\n            row.insert(j, triangle[i - 1][j - 1] + triangle[i - 1][j])\n        triangle.append(row)\n    return triangle[:num_rows]']",1000000,0.029609900200739503,0.031210426006000488,0.03436980000697076,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        new_row = [1]\n        for j in range(1, i):\n            new_row.append(prev_row[j - 1] + prev_row[j])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle']",1000,0.018965500174090266,0.01990254397969693,0.023801800096407533,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        new_row = [1]\n        for j in range(1, i):\n            new_row.append(prev_row[j - 1] + prev_row[j])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle']",10000,0.018894700100645423,0.01986326601356268,0.021092399954795837,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",6,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        prev_row = triangle[-1]\n        new_row = [1]\n        for j in range(1, i):\n            new_row.append(prev_row[j - 1] + prev_row[j])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle']",1000000,0.018845600076019764,0.019731101996731015,0.02129830000922084,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(num_rows):\n    pascal_triangle = []\n    for i in range(num_rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n        pascal_triangle.append(row)\n    return pascal_triangle']",1000,0.02445359993726015,0.02603218798758462,0.028133900137618184,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(num_rows):\n    pascal_triangle = []\n    for i in range(num_rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n        pascal_triangle.append(row)\n    return pascal_triangle']",10000,0.02476469986140728,0.02629520999966189,0.034315899945795536,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",7,"['def funcImp(num_rows):\n    pascal_triangle = []\n    for i in range(num_rows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = pascal_triangle[i - 1][j - 1] + pascal_triangle[i - 1][j]\n        pascal_triangle.append(row)\n    return pascal_triangle']",1000000,0.024413999868556857,0.02609049401246011,0.027946799993515015,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(n):\n    res = []\n    for i in range(n):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = res[i - 1][j - 1] + res[i - 1][j]\n        res.append(row)\n    return res']",1000,0.023704899940639734,0.025600322980899363,0.02953089983202517,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(n):\n    res = []\n    for i in range(n):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = res[i - 1][j - 1] + res[i - 1][j]\n        res.append(row)\n    return res']",10000,0.024400100111961365,0.02579538099002093,0.029907000018283725,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",8,"['def funcImp(n):\n    res = []\n    for i in range(n):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = res[i - 1][j - 1] + res[i - 1][j]\n        res.append(row)\n    return res']",1000000,0.024081600131466985,0.025722384992986916,0.02792669995687902,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(numRows):\n    result = [[1]]\n    for i in range(1, numRows):\n        newRow = [1]\n        for j in range(1, i):\n            newRow.append(result[-1][j - 1] + result[-1][j])\n        newRow.append(1)\n        result.append(newRow)\n    return result']",1000,0.025198000017553568,0.026631143018603323,0.03704009996727109,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(numRows):\n    result = [[1]]\n    for i in range(1, numRows):\n        newRow = [1]\n        for j in range(1, i):\n            newRow.append(result[-1][j - 1] + result[-1][j])\n        newRow.append(1)\n        result.append(newRow)\n    return result']",10000,0.025492999935522676,0.026612879005260767,0.02841389994136989,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",9,"['def funcImp(numRows):\n    result = [[1]]\n    for i in range(1, numRows):\n        newRow = [1]\n        for j in range(1, i):\n            newRow.append(result[-1][j - 1] + result[-1][j])\n        newRow.append(1)\n        result.append(newRow)\n    return result']",1000000,0.025363299995660782,0.027276389002799988,0.045037100091576576,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        new_row = [1]\n        for j in range(1, i):\n            new_row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle']",1000,0.026302499929443002,0.027881280009169132,0.029650900047272444,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        new_row = [1]\n        for j in range(1, i):\n            new_row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle']",10000,0.026716900058090687,0.02798052900005132,0.03660429990850389,N/A
3_p15_auto_pascal_triangle_strategy,"""Pascals Triangle for Python. The implementation should have the most optimal time complexity possible.  The implementation should be in a function named funcImp that takes a single number of raws as a parameter.""",10,"['def funcImp(num_rows):\n    triangle = [[1]]\n    for i in range(1, num_rows):\n        new_row = [1]\n        for j in range(1, i):\n            new_row.append(triangle[i - 1][j - 1] + triangle[i - 1][j])\n        new_row.append(1)\n        triangle.append(new_row)\n    return triangle']",1000000,0.026516499929130077,0.028039298988878726,0.03190279984846711,N/A
