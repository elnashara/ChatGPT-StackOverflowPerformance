function_index,prompt,sample_index,code_segment,Size,Min,Average,Max,Exception
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(arr):\n    """"""\n    Returns the maximum product subarray of a list of integers.\n    """"""\n    n = len(arr)\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_product = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_so_far, min_so_far) = (min_so_far, max_so_far)\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n        max_product = max(max_product, max_so_far)\n    return max_product']",1000,0.045937200000480516,0.0480259090002437,0.05334210000000894,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(arr):\n    """"""\n    Returns the maximum product subarray of a list of integers.\n    """"""\n    n = len(arr)\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_product = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_so_far, min_so_far) = (min_so_far, max_so_far)\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n        max_product = max(max_product, max_so_far)\n    return max_product']",2000,0.10605789999681292,0.1383159500000329,0.18195360000026994,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(arr):\n    """"""\n    Returns the maximum product subarray of a list of integers.\n    """"""\n    n = len(arr)\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_product = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_so_far, min_so_far) = (min_so_far, max_so_far)\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n        max_product = max(max_product, max_so_far)\n    return max_product']",5000,0.40232430000105524,0.6697120059999361,0.7238008999993326,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    n = len(nums)\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = nums[0]\n    for i in range(1, n):\n        temp = max_prod\n        max_prod = max(nums[i], max(nums[i] * max_prod, nums[i] * min_prod))\n        min_prod = min(nums[i], min(nums[i] * temp, nums[i] * min_prod))\n        result = max(result, max_prod)\n    return result']",1000,0.08485260000088601,0.08742290400026832,0.1046411999996053,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    n = len(nums)\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = nums[0]\n    for i in range(1, n):\n        temp = max_prod\n        max_prod = max(nums[i], max(nums[i] * max_prod, nums[i] * min_prod))\n        min_prod = min(nums[i], min(nums[i] * temp, nums[i] * min_prod))\n        result = max(result, max_prod)\n    return result']",2000,0.2583926999977848,0.2617524769999727,0.2727703999989899,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    n = len(nums)\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = nums[0]\n    for i in range(1, n):\n        temp = max_prod\n        max_prod = max(nums[i], max(nums[i] * max_prod, nums[i] * min_prod))\n        min_prod = min(nums[i], min(nums[i] * temp, nums[i] * min_prod))\n        result = max(result, max_prod)\n    return result']",5000,1.2844359999980952,1.29929141800003,1.506234600001335,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    curr_max = curr_min = max_prod = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (curr_max, curr_min) = (curr_min, curr_max)\n        curr_max = max(nums[i], curr_max * nums[i])\n        curr_min = min(nums[i], curr_min * nums[i])\n        max_prod = max(max_prod, curr_max)\n    return max_prod']",1000,0.04651010000088718,0.04802013299999089,0.0533514999988256,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    curr_max = curr_min = max_prod = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (curr_max, curr_min) = (curr_min, curr_max)\n        curr_max = max(nums[i], curr_max * nums[i])\n        curr_min = min(nums[i], curr_min * nums[i])\n        max_prod = max(max_prod, curr_max)\n    return max_prod']",2000,0.13564250000126776,0.13809247000026517,0.17276140000103624,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    curr_max = curr_min = max_prod = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (curr_max, curr_min) = (curr_min, curr_max)\n        curr_max = max(nums[i], curr_max * nums[i])\n        curr_min = min(nums[i], curr_min * nums[i])\n        max_prod = max(max_prod, curr_max)\n    return max_prod']",5000,0.6019583999986935,0.66535519700039,0.695667299998604,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_product = nums[0]\n    for i in range(1, n):\n        if nums[i] < 0:\n            (max_so_far, min_so_far) = (min_so_far, max_so_far)\n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        max_product = max(max_product, max_so_far)\n    return max_product']",1000,0.04648749999978463,0.04840417499999603,0.05773609999960172,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_product = nums[0]\n    for i in range(1, n):\n        if nums[i] < 0:\n            (max_so_far, min_so_far) = (min_so_far, max_so_far)\n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        max_product = max(max_product, max_so_far)\n    return max_product']",2000,0.13589139999749023,0.13808969600006094,0.16337030000067898,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_product = nums[0]\n    for i in range(1, n):\n        if nums[i] < 0:\n            (max_so_far, min_so_far) = (min_so_far, max_so_far)\n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        max_product = max(max_product, max_so_far)\n    return max_product']",5000,0.6197489000005589,0.6660143529999913,0.7328042000008281,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    res = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_prod, min_prod) = (min_prod, max_prod)\n        max_prod = max(nums[i], max_prod * nums[i])\n        min_prod = min(nums[i], min_prod * nums[i])\n        res = max(res, max_prod)\n    return res']",1000,0.04663049999726354,0.04837927999975364,0.0538245999996434,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    res = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_prod, min_prod) = (min_prod, max_prod)\n        max_prod = max(nums[i], max_prod * nums[i])\n        min_prod = min(nums[i], min_prod * nums[i])\n        res = max(res, max_prod)\n    return res']",2000,0.1358278000006976,0.1387070249999306,0.1453579000008176,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    res = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_prod, min_prod) = (min_prod, max_prod)\n        max_prod = max(nums[i], max_prod * nums[i])\n        min_prod = min(nums[i], min_prod * nums[i])\n        res = max(res, max_prod)\n    return res']",5000,0.39613680000184104,0.6632388829999764,0.6942415000012261,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    if len(nums) == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    ans = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(temp * nums[i], min_product * nums[i], nums[i])\n        ans = max(ans, max_product)\n    return ans']",1000,0.07803599999897415,0.07988224500000797,0.08571369999845047,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    if len(nums) == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    ans = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(temp * nums[i], min_product * nums[i], nums[i])\n        ans = max(ans, max_product)\n    return ans']",2000,0.24298869999984163,0.24681714200003627,0.25410330000158865,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    if len(nums) == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    ans = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(temp * nums[i], min_product * nums[i], nums[i])\n        ans = max(ans, max_product)\n    return ans']",5000,1.2379588000003423,1.2504321030000938,1.2717096000014863,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = min_product = global_max = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp * nums[i], min_product * nums[i])\n        global_max = max(global_max, max_product)\n    return global_max']",1000,0.07773639999868465,0.07983577700004389,0.08483110000088345,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = min_product = global_max = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp * nums[i], min_product * nums[i])\n        global_max = max(global_max, max_product)\n    return global_max']",2000,0.24308680000103777,0.24689337899999372,0.25614760000098613,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = min_product = global_max = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp * nums[i], min_product * nums[i])\n        global_max = max(global_max, max_product)\n    return global_max']",5000,1.0016818000003695,1.2533150740000565,1.2870014000000083,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    if not nums:\n        return 0\n    (max_product, min_product, max_so_far) = (nums[0], nums[0], nums[0])\n    for num in nums[1:]:\n        if num < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.04305039999962901,0.044436046000118946,0.04862510000020848,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    if not nums:\n        return 0\n    (max_product, min_product, max_so_far) = (nums[0], nums[0], nums[0])\n    for num in nums[1:]:\n        if num < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.1285466000008455,0.13077667499983364,0.13578989999950863,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    if not nums:\n        return 0\n    (max_product, min_product, max_so_far) = (nums[0], nums[0], nums[0])\n    for num in nums[1:]:\n        if num < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,0.4042094000033103,0.6540455879997898,0.8624257999981637,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    """"""\n    Find the maximum product subarray of a given list of integers.\n    \n    Args:\n    nums: list of integers\n    \n    Returns:\n    max_product: maximum product subarray\n    \n    """"""\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], nums[i] * max_product)\n        min_product = min(nums[i], nums[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.04645470000104979,0.04830049199976202,0.0521188999991864,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    """"""\n    Find the maximum product subarray of a given list of integers.\n    \n    Args:\n    nums: list of integers\n    \n    Returns:\n    max_product: maximum product subarray\n    \n    """"""\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], nums[i] * max_product)\n        min_product = min(nums[i], nums[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.13599120000071707,0.13813345200003824,0.1425228000007337,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    """"""\n    Find the maximum product subarray of a given list of integers.\n    \n    Args:\n    nums: list of integers\n    \n    Returns:\n    max_product: maximum product subarray\n    \n    """"""\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], nums[i] * max_product)\n        min_product = min(nums[i], nums[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,0.3999922000002698,0.6687626029998864,0.8675639999964915,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(nums):\n    cur_max = cur_min = max_so_far = nums[0]\n    for num in nums[1:]:\n        (cur_max, cur_min) = (max(num, cur_max * num, cur_min * num), min(num, cur_max * num, cur_min * num))\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far']",1000,0.0726580999980797,0.07457330800007185,0.07888219999949797,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(nums):\n    cur_max = cur_min = max_so_far = nums[0]\n    for num in nums[1:]:\n        (cur_max, cur_min) = (max(num, cur_max * num, cur_min * num), min(num, cur_max * num, cur_min * num))\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far']",2000,0.20909100000062608,0.2407608110000365,0.3315586999997322,N/A
0_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(nums):\n    cur_max = cur_min = max_so_far = nums[0]\n    for num in nums[1:]:\n        (cur_max, cur_min) = (max(num, cur_max * num, cur_min * num), min(num, cur_max * num, cur_min * num))\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far']",5000,1.2056464000015694,1.2287835960000666,1.409574799999973,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    max_product = nums[0]\n    min_product = nums[0]\n    global_max = nums[0]\n    for i in range(1, len(nums)):\n        max_prod_candidate = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_prod_candidate = min(nums[i], max_product * nums[i], min_product * nums[i])\n        max_product = max_prod_candidate\n        min_product = min_prod_candidate\n        if max_product > global_max:\n            global_max = max_product\n    return global_max']",1000,0.07575700000234065,0.07856205399992178,0.08449459999974351,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    max_product = nums[0]\n    min_product = nums[0]\n    global_max = nums[0]\n    for i in range(1, len(nums)):\n        max_prod_candidate = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_prod_candidate = min(nums[i], max_product * nums[i], min_product * nums[i])\n        max_product = max_prod_candidate\n        min_product = min_prod_candidate\n        if max_product > global_max:\n            global_max = max_product\n    return global_max']",2000,0.2378443999987212,0.2420980750000672,0.25059110000074725,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    max_product = nums[0]\n    min_product = nums[0]\n    global_max = nums[0]\n    for i in range(1, len(nums)):\n        max_prod_candidate = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_prod_candidate = min(nums[i], max_product * nums[i], min_product * nums[i])\n        max_product = max_prod_candidate\n        min_product = min_prod_candidate\n        if max_product > global_max:\n            global_max = max_product\n    return global_max']",5000,0.7245868000027258,1.2280328060001557,1.2643845999991754,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = nums[0]\n    for i in range(1, len(nums)):\n        curr_num = nums[i]\n        temp_max = max_prod * curr_num\n        temp_min = min_prod * curr_num\n        max_prod = max(curr_num, temp_max, temp_min)\n        min_prod = min(curr_num, temp_max, temp_min)\n        result = max(result, max_prod)\n    return result']",1000,0.04480329999933019,0.047037491999944905,0.06662789999973029,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = nums[0]\n    for i in range(1, len(nums)):\n        curr_num = nums[i]\n        temp_max = max_prod * curr_num\n        temp_min = min_prod * curr_num\n        max_prod = max(curr_num, temp_max, temp_min)\n        min_prod = min(curr_num, temp_max, temp_min)\n        result = max(result, max_prod)\n    return result']",2000,0.13198589999956312,0.13559685699987312,0.15265349999754108,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = nums[0]\n    for i in range(1, len(nums)):\n        curr_num = nums[i]\n        temp_max = max_prod * curr_num\n        temp_min = min_prod * curr_num\n        max_prod = max(curr_num, temp_max, temp_min)\n        min_prod = min(curr_num, temp_max, temp_min)\n        result = max(result, max_prod)\n    return result']",5000,0.6443662000019685,0.6551193849996707,0.6922755999985384,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_subarray = [arr[0]]\n    min_subarray = [arr[0]]\n    max_product = arr[0]\n    for i in range(1, len(arr)):\n        max_end = max(arr[i], arr[i] * max_subarray[-1], arr[i] * min_subarray[-1])\n        min_end = min(arr[i], arr[i] * max_subarray[-1], arr[i] * min_subarray[-1])\n        max_subarray.append(max_end)\n        min_subarray.append(min_end)\n        max_product = max(max_product, max_end)\n    return max_product']",1000,0.09259439999732422,0.09543054700006906,0.10083429999940563,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_subarray = [arr[0]]\n    min_subarray = [arr[0]]\n    max_product = arr[0]\n    for i in range(1, len(arr)):\n        max_end = max(arr[i], arr[i] * max_subarray[-1], arr[i] * min_subarray[-1])\n        min_end = min(arr[i], arr[i] * max_subarray[-1], arr[i] * min_subarray[-1])\n        max_subarray.append(max_end)\n        min_subarray.append(min_end)\n        max_product = max(max_product, max_end)\n    return max_product']",2000,0.2830409000016516,0.2967873029999464,0.40979929999957676,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_subarray = [arr[0]]\n    min_subarray = [arr[0]]\n    max_product = arr[0]\n    for i in range(1, len(arr)):\n        max_end = max(arr[i], arr[i] * max_subarray[-1], arr[i] * min_subarray[-1])\n        min_end = min(arr[i], arr[i] * max_subarray[-1], arr[i] * min_subarray[-1])\n        max_subarray.append(max_end)\n        min_subarray.append(min_end)\n        max_product = max(max_product, max_end)\n    return max_product']",5000,0.9235133000001952,1.5666861990001417,2.040520699996705,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    result = max_product\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        result = max(result, max_product)\n    return result']",1000,0.04613460000109626,0.047514299000213214,0.0519220000023779,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    result = max_product\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        result = max(result, max_product)\n    return result']",2000,0.13547819999803323,0.13816325800009507,0.14149360000010347,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    result = max_product\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        result = max(result, max_product)\n    return result']",5000,0.3970126000021992,0.6651867379997566,0.6955809000028239,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    max_product = nums[0]\n    min_product = nums[0]\n    max_product_so_far = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        max_product_so_far = max(max_product_so_far, max_product)\n    return max_product_so_far']",1000,0.046469900000374764,0.048011612000045716,0.051715100002184045,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    max_product = nums[0]\n    min_product = nums[0]\n    max_product_so_far = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        max_product_so_far = max(max_product_so_far, max_product)\n    return max_product_so_far']",2000,0.13471579999895766,0.1372006410000904,0.13956079999843496,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    max_product = nums[0]\n    min_product = nums[0]\n    max_product_so_far = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        max_product_so_far = max(max_product_so_far, max_product)\n    return max_product_so_far']",5000,0.39497949999713455,0.6635254020002685,0.681812800001353,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_so_far\n        max_so_far = max(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        min_so_far = min(nums[i], temp * nums[i], min_so_far * nums[i])\n        max_prod = max(max_prod, max_so_far)\n    return max_prod']",1000,0.05759089999992284,0.08132866600000853,0.0865814999997383,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_so_far\n        max_so_far = max(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        min_so_far = min(nums[i], temp * nums[i], min_so_far * nums[i])\n        max_prod = max(max_prod, max_so_far)\n    return max_prod']",2000,0.18213159999868367,0.24865499299994553,0.28914889999941806,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_so_far\n        max_so_far = max(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        min_so_far = min(nums[i], temp * nums[i], min_so_far * nums[i])\n        max_prod = max(max_prod, max_so_far)\n    return max_prod']",5000,0.7428504999988945,1.2626178889999937,1.3634396999987075,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        num = nums[i]\n        max_prod_temp = max(num, max_prod * num, min_prod * num)\n        min_prod_temp = min(num, max_prod * num, min_prod * num)\n        max_so_far = max(max_so_far, max_prod_temp)\n        max_prod = max_prod_temp\n        min_prod = min_prod_temp\n    return max_so_far']",1000,0.07583190000150353,0.07849206900002173,0.08912639999834937,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        num = nums[i]\n        max_prod_temp = max(num, max_prod * num, min_prod * num)\n        min_prod_temp = min(num, max_prod * num, min_prod * num)\n        max_so_far = max(max_so_far, max_prod_temp)\n        max_prod = max_prod_temp\n        min_prod = min_prod_temp\n    return max_so_far']",2000,0.1755529000001843,0.2396541029999571,0.24598630000036792,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        num = nums[i]\n        max_prod_temp = max(num, max_prod * num, min_prod * num)\n        min_prod_temp = min(num, max_prod * num, min_prod * num)\n        max_so_far = max(max_so_far, max_prod_temp)\n        max_prod = max_prod_temp\n        min_prod = min_prod_temp\n    return max_so_far']",5000,0.7570897000005061,1.2297516319998976,1.261186200001248,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    max_prod = [0] * len(nums)\n    min_prod = [0] * len(nums)\n    max_prod[0] = nums[0]\n    min_prod[0] = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] >= 0:\n            max_prod[i] = max(nums[i], nums[i] * max_prod[i - 1])\n            min_prod[i] = min(nums[i], nums[i] * min_prod[i - 1])\n        else:\n            max_prod[i] = max(nums[i], nums[i] * min_prod[i - 1])\n            min_prod[i] = min(nums[i], nums[i] * max_prod[i - 1])\n    return max(max_prod)']",1000,0.05291450000004261,0.05466946699987602,0.05817609999940032,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    max_prod = [0] * len(nums)\n    min_prod = [0] * len(nums)\n    max_prod[0] = nums[0]\n    min_prod[0] = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] >= 0:\n            max_prod[i] = max(nums[i], nums[i] * max_prod[i - 1])\n            min_prod[i] = min(nums[i], nums[i] * min_prod[i - 1])\n        else:\n            max_prod[i] = max(nums[i], nums[i] * min_prod[i - 1])\n            min_prod[i] = min(nums[i], nums[i] * max_prod[i - 1])\n    return max(max_prod)']",2000,0.15732349999962025,0.1634469500001069,0.16948349999802304,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    max_prod = [0] * len(nums)\n    min_prod = [0] * len(nums)\n    max_prod[0] = nums[0]\n    min_prod[0] = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] >= 0:\n            max_prod[i] = max(nums[i], nums[i] * max_prod[i - 1])\n            min_prod[i] = min(nums[i], nums[i] * min_prod[i - 1])\n        else:\n            max_prod[i] = max(nums[i], nums[i] * min_prod[i - 1])\n            min_prod[i] = min(nums[i], nums[i] * max_prod[i - 1])\n    return max(max_prod)']",5000,0.5232609000013326,0.9188209480001024,0.9826218000016524,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(lst):\n    if not lst:\n        return 0\n    max_product = lst[0]\n    min_product = lst[0]\n    global_max = lst[0]\n    for i in range(1, len(lst)):\n        curr = lst[i]\n        temp_max = max(curr, max_product * curr, min_product * curr)\n        min_product = min(curr, max_product * curr, min_product * curr)\n        max_product = temp_max\n        global_max = max(global_max, max_product)\n    return global_max']",1000,0.07586760000049253,0.07765973199973814,0.08277459999953862,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(lst):\n    if not lst:\n        return 0\n    max_product = lst[0]\n    min_product = lst[0]\n    global_max = lst[0]\n    for i in range(1, len(lst)):\n        curr = lst[i]\n        temp_max = max(curr, max_product * curr, min_product * curr)\n        min_product = min(curr, max_product * curr, min_product * curr)\n        max_product = temp_max\n        global_max = max(global_max, max_product)\n    return global_max']",2000,0.23307910000221455,0.23886206700011825,0.24942549999832409,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(lst):\n    if not lst:\n        return 0\n    max_product = lst[0]\n    min_product = lst[0]\n    global_max = lst[0]\n    for i in range(1, len(lst)):\n        curr = lst[i]\n        temp_max = max(curr, max_product * curr, min_product * curr)\n        min_product = min(curr, max_product * curr, min_product * curr)\n        max_product = temp_max\n        global_max = max(global_max, max_product)\n    return global_max']",5000,1.1975573000017903,1.227773309999975,1.2633196999995562,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    max_ans = arr[0]\n    for i in range(1, len(arr)):\n        curr_num = arr[i]\n        temp_max = max_prod\n        max_prod = max(curr_num, max(curr_num * max_prod, curr_num * min_prod))\n        min_prod = min(curr_num, min(curr_num * temp_max, curr_num * min_prod))\n        max_ans = max(max_ans, max_prod)\n    return max_ans']",1000,0.08224280000285944,0.08506059099989216,0.09076889999778359,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    max_ans = arr[0]\n    for i in range(1, len(arr)):\n        curr_num = arr[i]\n        temp_max = max_prod\n        max_prod = max(curr_num, max(curr_num * max_prod, curr_num * min_prod))\n        min_prod = min(curr_num, min(curr_num * temp_max, curr_num * min_prod))\n        max_ans = max(max_ans, max_prod)\n    return max_ans']",2000,0.2514086999981373,0.25466456600010134,0.2616420000013022,N/A
1_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be fast as the size of the list grows. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_prod = arr[0]\n    min_prod = arr[0]\n    max_ans = arr[0]\n    for i in range(1, len(arr)):\n        curr_num = arr[i]\n        temp_max = max_prod\n        max_prod = max(curr_num, max(curr_num * max_prod, curr_num * min_prod))\n        min_prod = min(curr_num, min(curr_num * temp_max, curr_num * min_prod))\n        max_ans = max(max_ans, max_prod)\n    return max_ans']",5000,1.256681299997581,1.2690019320001376,1.2820087000000058,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    max_ending_here = nums[0]\n    min_ending_here = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_ending_here, min_ending_here) = (min_ending_here, max_ending_here)\n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n        max_product = max(max_product, max_ending_here)\n    return max_product']",1000,0.038260200002696365,0.04780919199984055,0.05422330000146758,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    max_ending_here = nums[0]\n    min_ending_here = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_ending_here, min_ending_here) = (min_ending_here, max_ending_here)\n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n        max_product = max(max_product, max_ending_here)\n    return max_product']",2000,0.13466689999768278,0.13727297700024793,0.14002919999620644,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    max_ending_here = nums[0]\n    min_ending_here = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            (max_ending_here, min_ending_here) = (min_ending_here, max_ending_here)\n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n        max_product = max(max_product, max_ending_here)\n    return max_product']",5000,0.47935950000101,0.6661726830001135,0.6897300999989966,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.04685080000490416,0.048403286000102526,0.059709100001782645,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.13511589999689022,0.13801167799974792,0.1417130999980145,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(arr):\n    if not arr:\n        return 0\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,0.6550229000058607,0.6658153560005303,0.6746854000011808,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_prod = nums[0]\n    for i in range(1, len(nums)):\n        tmp_max = max(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        tmp_min = min(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        max_so_far = tmp_max\n        min_so_far = tmp_min\n        max_prod = max(max_prod, max_so_far)\n    return max_prod']",1000,0.07696980000037001,0.07895699500077172,0.08428519999870332,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_prod = nums[0]\n    for i in range(1, len(nums)):\n        tmp_max = max(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        tmp_min = min(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        max_so_far = tmp_max\n        min_so_far = tmp_min\n        max_prod = max(max_prod, max_so_far)\n    return max_prod']",2000,0.2426502000016626,0.24575445900023624,0.24925520000397228,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_prod = nums[0]\n    for i in range(1, len(nums)):\n        tmp_max = max(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        tmp_min = min(nums[i], max_so_far * nums[i], min_so_far * nums[i])\n        max_so_far = tmp_max\n        min_so_far = tmp_min\n        max_prod = max(max_prod, max_so_far)\n    return max_prod']",5000,1.2333760999972583,1.2496904210002686,1.2661411999943084,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(lst):\n    if not lst:\n        return 0\n    max_product = lst[0]\n    min_product = lst[0]\n    max_so_far = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(lst[i], max_product * lst[i])\n        min_product = min(lst[i], min_product * lst[i])\n        max_so_far = max(max_product, max_so_far)\n    return max_so_far']",1000,0.046404300002905075,0.047851510000327835,0.05423349999909988,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(lst):\n    if not lst:\n        return 0\n    max_product = lst[0]\n    min_product = lst[0]\n    max_so_far = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(lst[i], max_product * lst[i])\n        min_product = min(lst[i], min_product * lst[i])\n        max_so_far = max(max_product, max_so_far)\n    return max_so_far']",2000,0.13520419999986188,0.1376765379994322,0.14198790000227746,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"['def funcImp(lst):\n    if not lst:\n        return 0\n    max_product = lst[0]\n    min_product = lst[0]\n    max_so_far = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(lst[i], max_product * lst[i])\n        min_product = min(lst[i], min_product * lst[i])\n        max_so_far = max(max_product, max_so_far)\n    return max_so_far']",5000,0.6596736000064993,0.6664787679995061,0.6786043000029167,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    curr_max = curr_min = max_prod = nums[0]\n    for i in range(1, n):\n        temp = curr_max\n        curr_max = max(curr_max * nums[i], curr_min * nums[i], nums[i])\n        curr_min = min(temp * nums[i], curr_min * nums[i], nums[i])\n        max_prod = max(max_prod, curr_max)\n    return max_prod']",1000,0.07666449999669567,0.07811666600005993,0.08245119999628514,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    curr_max = curr_min = max_prod = nums[0]\n    for i in range(1, n):\n        temp = curr_max\n        curr_max = max(curr_max * nums[i], curr_min * nums[i], nums[i])\n        curr_min = min(temp * nums[i], curr_min * nums[i], nums[i])\n        max_prod = max(max_prod, curr_max)\n    return max_prod']",2000,0.24115900000469992,0.2440881720001198,0.2504190000036033,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    curr_max = curr_min = max_prod = nums[0]\n    for i in range(1, n):\n        temp = curr_max\n        curr_max = max(curr_max * nums[i], curr_min * nums[i], nums[i])\n        curr_min = min(temp * nums[i], curr_min * nums[i], nums[i])\n        max_prod = max(max_prod, curr_max)\n    return max_prod']",5000,0.9385122999956366,1.2421633720000682,1.257393799998681,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], arr[i] * max_product)\n        min_product = min(arr[i], arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.04607730000134325,0.04745703000065987,0.05153180000343127,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], arr[i] * max_product)\n        min_product = min(arr[i], arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.13301379999757046,0.1366228369995224,0.140639099998225,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], arr[i] * max_product)\n        min_product = min(arr[i], arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,0.6582677999977022,0.665001297999479,0.6752642999999807,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    res = max_so_far\n    for i in range(1, len(nums)):\n        num = nums[i]\n        temp_max = max(num, max_so_far * num, min_so_far * num)\n        min_so_far = min(num, max_so_far * num, min_so_far * num)\n        max_so_far = temp_max\n        res = max(res, max_so_far)\n    return res']",1000,0.058695300002000295,0.07484911000065039,0.07931760000064969,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    res = max_so_far\n    for i in range(1, len(nums)):\n        num = nums[i]\n        temp_max = max(num, max_so_far * num, min_so_far * num)\n        min_so_far = min(num, max_so_far * num, min_so_far * num)\n        max_so_far = temp_max\n        res = max(res, max_so_far)\n    return res']",2000,0.23586539999814704,0.2384757039998658,0.24339830000099028,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    res = max_so_far\n    for i in range(1, len(nums)):\n        num = nums[i]\n        temp_max = max(num, max_so_far * num, min_so_far * num)\n        min_so_far = min(num, max_so_far * num, min_so_far * num)\n        max_so_far = temp_max\n        res = max(res, max_so_far)\n    return res']",5000,0.785885800003598,1.2337367320003978,1.2518121000030078,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(arr):\n    n = len(arr)\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    for i in range(1, n):\n        curr = arr[i]\n        temp_max = max(curr, max_ending_here * curr, min_ending_here * curr)\n        min_ending_here = min(curr, max_ending_here * curr, min_ending_here * curr)\n        max_ending_here = temp_max\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far']",1000,0.07377670000278158,0.07538281600012851,0.08035630000085803,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(arr):\n    n = len(arr)\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    for i in range(1, n):\n        curr = arr[i]\n        temp_max = max(curr, max_ending_here * curr, min_ending_here * curr)\n        min_ending_here = min(curr, max_ending_here * curr, min_ending_here * curr)\n        max_ending_here = temp_max\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far']",2000,0.23617360000207555,0.23833550499999545,0.24252010000054725,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(arr):\n    n = len(arr)\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    for i in range(1, n):\n        curr = arr[i]\n        temp_max = max(curr, max_ending_here * curr, min_ending_here * curr)\n        min_ending_here = min(curr, max_ending_here * curr, min_ending_here * curr)\n        max_ending_here = temp_max\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far']",5000,0.7117356000017026,1.2312636619996191,1.2659373999995296,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        new_max_prod = max(nums[i], max_prod * nums[i], min_prod * nums[i])\n        new_min_prod = min(nums[i], max_prod * nums[i], min_prod * nums[i])\n        max_so_far = max(max_so_far, new_max_prod)\n        max_prod = new_max_prod\n        min_prod = new_min_prod\n    return max_so_far']",1000,0.0772821999998996,0.0789630929996929,0.08368830000108574,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        new_max_prod = max(nums[i], max_prod * nums[i], min_prod * nums[i])\n        new_min_prod = min(nums[i], max_prod * nums[i], min_prod * nums[i])\n        max_so_far = max(max_so_far, new_max_prod)\n        max_prod = new_max_prod\n        min_prod = new_min_prod\n    return max_so_far']",2000,0.24228669999865815,0.24523753099951137,0.2498286000045482,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        new_max_prod = max(nums[i], max_prod * nums[i], min_prod * nums[i])\n        new_min_prod = min(nums[i], max_prod * nums[i], min_prod * nums[i])\n        max_so_far = max(max_so_far, new_max_prod)\n        max_prod = new_max_prod\n        min_prod = new_min_prod\n    return max_so_far']",5000,0.7173360000015236,1.2392748940000455,1.2660541999939596,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.046653799996420275,0.04793573099967034,0.05262129999755416,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.13532890000351472,0.13758617899991804,0.1472933000040939,N/A
2_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n    max_so_far = arr[0]\n    for i in range(1, n):\n        if arr[i] < 0:\n            (max_product, min_product) = (min_product, max_product)\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,0.6624737999954959,0.6697987509999075,0.6803177000037977,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    if not nums:\n        return 0\n    prod_max = prod_min = res = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            (prod_max, prod_min) = (prod_min, prod_max)\n        prod_max = max(num, prod_max * num)\n        prod_min = min(num, prod_min * num)\n        res = max(res, prod_max)\n    return res']",1000,0.042741299999761395,0.04393426200025715,0.04703449999942677,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    if not nums:\n        return 0\n    prod_max = prod_min = res = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            (prod_max, prod_min) = (prod_min, prod_max)\n        prod_max = max(num, prod_max * num)\n        prod_min = min(num, prod_min * num)\n        res = max(res, prod_max)\n    return res']",2000,0.0913561999986996,0.12962867499998537,0.132603799997014,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",1,"['def funcImp(nums):\n    if not nums:\n        return 0\n    prod_max = prod_min = res = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            (prod_max, prod_min) = (prod_min, prod_max)\n        prod_max = max(num, prod_max * num)\n        prod_min = min(num, prod_min * num)\n        res = max(res, prod_max)\n    return res']",5000,0.5886051999987103,0.6578397299996869,0.7024929999970482,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_product = nums[0]\n    for i in range(1, len(nums)):\n        curr_num = nums[i]\n        temp_max = max(curr_num, max_so_far * curr_num, min_so_far * curr_num)\n        min_so_far = min(curr_num, max_so_far * curr_num, min_so_far * curr_num)\n        max_so_far = temp_max\n        max_product = max(max_product, max_so_far)\n    return max_product']",1000,0.07529539999814006,0.07703824199983501,0.08459230000153184,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_product = nums[0]\n    for i in range(1, len(nums)):\n        curr_num = nums[i]\n        temp_max = max(curr_num, max_so_far * curr_num, min_so_far * curr_num)\n        min_so_far = min(curr_num, max_so_far * curr_num, min_so_far * curr_num)\n        max_so_far = temp_max\n        max_product = max(max_product, max_so_far)\n    return max_product']",2000,0.23607669999910286,0.23982113899983232,0.252261699999508,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",2,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_product = nums[0]\n    for i in range(1, len(nums)):\n        curr_num = nums[i]\n        temp_max = max(curr_num, max_so_far * curr_num, min_so_far * curr_num)\n        min_so_far = min(curr_num, max_so_far * curr_num, min_so_far * curr_num)\n        max_so_far = temp_max\n        max_product = max(max_product, max_so_far)\n    return max_product']",5000,1.2219237000026624,1.2357981650005967,1.2542543000017758,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    if not nums:\n        return 0\n    n = len(nums)\n    max_prod = nums[0]\n    min_prod = nums[0]\n    ans = nums[0]\n    for i in range(1, n):\n        curr = nums[i]\n        temp = max_prod\n        max_prod = max(curr, max(max_prod * curr, min_prod * curr))\n        min_prod = min(curr, min(temp * curr, min_prod * curr))\n        ans = max(ans, max_prod)\n    return ans']",1000,0.08118560000002617,0.0830751099999179,0.0891669999982696,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    if not nums:\n        return 0\n    n = len(nums)\n    max_prod = nums[0]\n    min_prod = nums[0]\n    ans = nums[0]\n    for i in range(1, n):\n        curr = nums[i]\n        temp = max_prod\n        max_prod = max(curr, max(max_prod * curr, min_prod * curr))\n        min_prod = min(curr, min(temp * curr, min_prod * curr))\n        ans = max(ans, max_prod)\n    return ans']",2000,0.21461009999620728,0.25305102399972385,0.2581036000046879,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",3,"['def funcImp(nums):\n    if not nums:\n        return 0\n    n = len(nums)\n    max_prod = nums[0]\n    min_prod = nums[0]\n    ans = nums[0]\n    for i in range(1, n):\n        curr = nums[i]\n        temp = max_prod\n        max_prod = max(curr, max(max_prod * curr, min_prod * curr))\n        min_prod = min(curr, min(temp * curr, min_prod * curr))\n        ans = max(ans, max_prod)\n    return ans']",5000,0.908459700003732,1.2684411569998337,1.2813310000055935,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"[""def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = float('-inf')\n    cur_product = 1\n    for num in nums:\n        cur_product *= num\n        max_product = max(max_product, cur_product)\n        if cur_product == 0:\n            cur_product = 1\n    cur_product = 1\n    for num in reversed(nums):\n        cur_product *= num\n        max_product = max(max_product, cur_product)\n        if cur_product == 0:\n            cur_product = 1\n    return max_product""]",1000,0.06532110000262037,0.0669571769997856,0.06993130000046222,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"[""def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = float('-inf')\n    cur_product = 1\n    for num in nums:\n        cur_product *= num\n        max_product = max(max_product, cur_product)\n        if cur_product == 0:\n            cur_product = 1\n    cur_product = 1\n    for num in reversed(nums):\n        cur_product *= num\n        max_product = max(max_product, cur_product)\n        if cur_product == 0:\n            cur_product = 1\n    return max_product""]",2000,0.215583000004699,0.2184668709995458,0.22572629999922356,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",4,"[""def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = float('-inf')\n    cur_product = 1\n    for num in nums:\n        cur_product *= num\n        max_product = max(max_product, cur_product)\n        if cur_product == 0:\n            cur_product = 1\n    cur_product = 1\n    for num in reversed(nums):\n        cur_product *= num\n        max_product = max(max_product, cur_product)\n        if cur_product == 0:\n            cur_product = 1\n    return max_product""]",5000,1.0038010999996914,1.1947986889996536,1.230913799998234,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['from typing import List\n\ndef funcImp(nums: List[int]) -> int:\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n    for i in range(1, n):\n        current_num = nums[i]\n        temp_max_product = max(current_num, max_product * current_num, min_product * current_num)\n        min_product = min(current_num, max_product * current_num, min_product * current_num)\n        max_product = temp_max_product\n        result = max(result, max_product)\n    return result']",1000,0.074018100000103,0.07578100200014887,0.08037949999561533,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['from typing import List\n\ndef funcImp(nums: List[int]) -> int:\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n    for i in range(1, n):\n        current_num = nums[i]\n        temp_max_product = max(current_num, max_product * current_num, min_product * current_num)\n        min_product = min(current_num, max_product * current_num, min_product * current_num)\n        max_product = temp_max_product\n        result = max(result, max_product)\n    return result']",2000,0.23521529999561608,0.23989700799946148,0.2532548999952269,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",5,"['from typing import List\n\ndef funcImp(nums: List[int]) -> int:\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n    for i in range(1, n):\n        current_num = nums[i]\n        temp_max_product = max(current_num, max_product * current_num, min_product * current_num)\n        min_product = min(current_num, max_product * current_num, min_product * current_num)\n        max_product = temp_max_product\n        result = max(result, max_product)\n    return result']",5000,1.2018970999997691,1.2543306320001284,1.6420135000007576,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    if not nums:\n        return\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        temp_max = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp_max * nums[i], min_product * nums[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.07718770000064978,0.0788093739998294,0.08396969999739667,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    if not nums:\n        return\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        temp_max = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp_max * nums[i], min_product * nums[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.24109519999910844,0.24632147800031817,0.28609100000176113,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",6,"['def funcImp(nums):\n    if not nums:\n        return\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        temp_max = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp_max * nums[i], min_product * nums[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,1.2434554000064963,1.2668242430004466,1.4754222000046866,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = max_prod\n    for i in range(1, len(nums)):\n        temp_max_prod = max_prod * nums[i]\n        temp_min_prod = min_prod * nums[i]\n        max_prod = max(nums[i], temp_max_prod, temp_min_prod)\n        min_prod = min(nums[i], temp_max_prod, temp_min_prod)\n        result = max(result, max_prod)\n    return result']",1000,0.04649730000528507,0.04804381999965699,0.05245170000125654,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = max_prod\n    for i in range(1, len(nums)):\n        temp_max_prod = max_prod * nums[i]\n        temp_min_prod = min_prod * nums[i]\n        max_prod = max(nums[i], temp_max_prod, temp_min_prod)\n        min_prod = min(nums[i], temp_max_prod, temp_min_prod)\n        result = max(result, max_prod)\n    return result']",2000,0.1354817000028561,0.13862640500032286,0.1413925999950152,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",7,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = max_prod\n    for i in range(1, len(nums)):\n        temp_max_prod = max_prod * nums[i]\n        temp_min_prod = min_prod * nums[i]\n        max_prod = max(nums[i], temp_max_prod, temp_min_prod)\n        min_prod = min(nums[i], temp_max_prod, temp_min_prod)\n        result = max(result, max_prod)\n    return result']",5000,0.6576838000037242,0.6710110220000933,0.6879436999952304,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = min_prod = max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        curr = nums[i]\n        temp_max = max(curr, max_prod * curr, min_prod * curr)\n        min_prod = min(curr, max_prod * curr, min_prod * curr)\n        max_prod = temp_max\n        max_so_far = max(max_so_far, max_prod)\n    return max_so_far']",1000,0.07305799999448936,0.07533001399991918,0.08036670000001322,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = min_prod = max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        curr = nums[i]\n        temp_max = max(curr, max_prod * curr, min_prod * curr)\n        min_prod = min(curr, max_prod * curr, min_prod * curr)\n        max_prod = temp_max\n        max_so_far = max(max_so_far, max_prod)\n    return max_so_far']",2000,0.2356216999978642,0.23905989199985925,0.25095349999901373,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",8,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_prod = min_prod = max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        curr = nums[i]\n        temp_max = max(curr, max_prod * curr, min_prod * curr)\n        min_prod = min(curr, max_prod * curr, min_prod * curr)\n        max_prod = temp_max\n        max_so_far = max(max_so_far, max_prod)\n    return max_so_far']",5000,1.2253801000042586,1.2419363520002662,1.2549077000003308,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        prev_max = max_product\n        prev_min = min_product\n        max_product = max(nums[i], prev_max * nums[i], prev_min * nums[i])\n        min_product = min(nums[i], prev_max * nums[i], prev_min * nums[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",1000,0.078077400001348,0.07964911999988544,0.08506289999786532,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        prev_max = max_product\n        prev_min = min_product\n        max_product = max(nums[i], prev_max * nums[i], prev_min * nums[i])\n        min_product = min(nums[i], prev_max * nums[i], prev_min * nums[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",2000,0.2437560999969719,0.24737382100036484,0.25883940000494476,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",9,"['def funcImp(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n    for i in range(1, len(nums)):\n        prev_max = max_product\n        prev_min = min_product\n        max_product = max(nums[i], prev_max * nums[i], prev_min * nums[i])\n        min_product = min(nums[i], prev_max * nums[i], prev_min * nums[i])\n        max_so_far = max(max_so_far, max_product)\n    return max_so_far']",5000,1.2503759000028367,1.261434295000363,1.2807557999985875,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    result = max_so_far\n    for i in range(1, n):\n        curr = nums[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n        max_so_far = temp_max\n        result = max(result, max_so_far)\n    return result']",1000,0.07429469999624416,0.07584181699945475,0.0804102000038256,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    result = max_so_far\n    for i in range(1, n):\n        curr = nums[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n        max_so_far = temp_max\n        result = max(result, max_so_far)\n    return result']",2000,0.23584970000229077,0.23819965599985152,0.24128339999879245,N/A
3_p10_auto_maximum_product_subarray_strategy,"""Maximum Product Subarray. The implementation should have the most optimal time complexity possible. The implementation should be in a function named funcImp that takes a single list of integers as a parameter.""",10,"['def funcImp(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    result = max_so_far\n    for i in range(1, n):\n        curr = nums[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n        max_so_far = temp_max\n        result = max(result, max_so_far)\n    return result']",5000,0.8677255000002333,1.2384236599999712,1.2543636999980663,N/A
